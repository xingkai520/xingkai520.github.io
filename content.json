{"meta":{"title":"Hexo","subtitle":"","description":"","author":"xingkai","url":"https://xingkai520.github.io","root":"/"},"pages":[],"posts":[{"title":"JS中的作用域（Scope）","slug":"JS中的作用域（Scope）","date":"2020-05-20T08:07:55.000Z","updated":"2020-05-20T09:35:05.726Z","comments":true,"path":"2020/05/20/JS中的作用域（Scope）/","link":"","permalink":"https://xingkai520.github.io/2020/05/20/JS%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Scope%EF%BC%89/","excerpt":"作用域 作用域指一个变量的作用范围 在JS中有两种作用域 1.全局作用域 2.函数作用域","text":"作用域 作用域指一个变量的作用范围 在JS中有两种作用域 1.全局作用域 2.函数作用域 全局作用域 直接编写在script标签中的js代码，都在全局作用域 全局作用域在页面打开时创建，在页面关闭时销毁 在全局作用域中，有一个全局对象window，我们可以直接使用 ​ 他代表的是一个浏览器端口，他由浏览器创建，可以直接在浏览器中使用 在全局作用域中， ​ 创建的变量都会作为window对象的属性保存 ​ 创建的函数都会作为window对象的方法保存 全局作用域中的变量都是全局变量 ​ 在页面的任意部分都可以访问的到 1234567891011console.log(window);//输出 [object window]var a = 10;console.log(window.a);//输出 10function fun()&#123; console.log(\"我是fun函数\");&#125;window.fun()//输出 我是fun函数window.alert(\"hello\");//输出hello 函数作用域 调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁 每调用一次函数都会创建一个新的函数作用域，他们之间是相互独立的 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量 当在函数作用域中操作一个变量时，他会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中找，如果到全局作用域中也找不到就会报错 函数中要访问全局变量要使用window函数 在函数作用域中也有声明提前的特性 函数声明也会在函数所有代码执行之前执行 定义形参就相当于在函数作用域中声明了变量 123456789101112131415161718192021var a = 10;function fun()&#123; var a = \"我是fun函数中的a\" console.log(a);//输出 我是fun函数中的a var b = 20; function fun2()&#123; console.log(a);//输出 我是fun函数中的a console.log(window.a)//输出 10 &#125;&#125;console.log(b);fun();//输出10fun();fun();var e = 23;function fun6(e)&#123;//相当于在函数中var e alert(e);&#125;fun();//输出undefined","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"this","slug":"this","date":"2020-05-20T08:07:55.000Z","updated":"2020-05-26T07:31:22.444Z","comments":true,"path":"2020/05/20/this/","link":"","permalink":"https://xingkai520.github.io/2020/05/20/this/","excerpt":"解析器在调用函数每次都会向函数内部传递一个隐含的参数 这个隐含的参数就是this，this指向的是一个对象 这个对象我们称为函数执行的上下文对象 根据函数的调用方式的不同，this会指向不同的对象 ​ 1.以函数的形式调用时，this永远都是window ​ 2.以方法的形式调用时，this就是调用方法的那个对象 ​ 3.当以构造函数的形式调用时，this就是新创建的那个对象","text":"解析器在调用函数每次都会向函数内部传递一个隐含的参数 这个隐含的参数就是this，this指向的是一个对象 这个对象我们称为函数执行的上下文对象 根据函数的调用方式的不同，this会指向不同的对象 ​ 1.以函数的形式调用时，this永远都是window ​ 2.以方法的形式调用时，this就是调用方法的那个对象 ​ 3.当以构造函数的形式调用时，this就是新创建的那个对象 12345678910111213var name = \"全局\";function fun()&#123; console.log(this.name);//this.name表示谁调用就用谁里面的元素（谁调指谁）&#125;var obj = &#123; name:\"孙悟空\", sayName:fun &#125;var obj2 = &#123; name:\"沙和尚\", sayName:fun&#125;obj2.sayName();//输出沙和尚","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"js中的函数","slug":"js函数","date":"2020-05-14T06:10:09.000Z","updated":"2020-05-26T08:44:40.434Z","comments":true,"path":"2020/05/14/js函数/","link":"","permalink":"https://xingkai520.github.io/2020/05/14/js%E5%87%BD%E6%95%B0/","excerpt":"函数 函数也是一个对象 函数中可以装一些功能（代码），在需要时可以执行这些功能（代码）","text":"函数 函数也是一个对象 函数中可以装一些功能（代码），在需要时可以执行这些功能（代码） 创建函数对象12var fun = new Function();console.log(typeof fun);//返回function 可以将要封装的代码以字符串的形式传递给构造函数； 12var fun = new Function(\"console.log('这是一个函数');\");console.log(fun);//返回警告 封装到函数中的代码不会立即执行，函数中的代码会在函数调用时执行 在开发中很少用构造函数来创建一个函数对象 使用函数声明来创建一个函数 语法： ​ function 函数名（[形参1，形参2，….形参n]）{ ​ 函数体； ​ } 123456function fun2()&#123; console.log(\"这是第二个函数\"); alert(\"哈哈哈哈哈\"); document.write(\"啦啦啦啦\");&#125;fun2()//按顺序执行这三行代码 使用函数表达式来创建一个函数 语法 var 函数名 = function([形参1，形参2，…….形参n]){ ​ 语句…..； ​ } 1234var fun3 = function()&#123; console.log(\"我是匿名函数中的代码\");&#125;fun3();//执行函数中代码 构造函数可以创建一个构造函数专门用来创建person对象的，构造函数就是一个普通的含数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写 构造函数和普通函数的区别就是调用方式的不同 普通函数是直接调用，而构造函数需要使用new关键字来使用 构造函数的执行流程 1.立刻创建一个新的对象 2.将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建对象 3.逐行执行函数中的代码 4.将新建的对象作为返回值返回 使用同一个同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 123456function Person()&#123; this.name\"孙悟空\"&#125;var per = new Person();console.log(per)//输出不在是Object&#123;孙悟空&#125;而是person&#123;孙悟空&#125;console.log(per instanceof person);//使用instanceof可以检查一个对象是否是一个类的实例，是true，否false，所有的对象都是Object的后代，所以检查是否是Object类时全是true 123456789101112131415function Person(name , age , gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sayName = function () &#123; alert(this.name) &#125;&#125;var per2 = new Person(\"猪八戒\" , 28 , \"男\");var per3 = new Person(\"沙和尚\" , 28 , \"男\");var per4 = new Person(\"唐僧\" , 38 , \"男\");obj2.sayName();obj4.sayName();console.log(per2.sayName == per4.sayName);//输出false说明这两个sayName方法是独立创建的 在person构造函数中，为每一个对象都添加了一个sayName的方法 目前我们的方法是在构建函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法 也就是所有实例的sayName都是唯一的 这样就导致了构建函数执行一次就会创建一个新方法，执行100000次就会创建100000个新方法，而100000个方法都是一模一样的，这是完全没有必要的，完全可以使所有的对象共享用一个方法 将sayName方法在全局作用域中定义 12345678910111213141516function Person(name , age , gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sayName = fun;&#125;function fun()&#123; alert(this.name);&#125;var per2 = new Person(\"猪八戒\" , 28 , \"男\");var per3 = new Person(\"沙和尚\" , 28 , \"男\");var per4 = new Person(\"唐僧\" , 38 , \"男\");per2.sayName();per4.sayName();console.log(per2.sayName == per4.sayName);//输出true，说明这两个sayName方法是共用的 将函数定义在全局作用域中会占用全局作用域的命名空间，而且定义在全局作用域中也很不安全。尽量不要在全局作用域中定义函数 调用函数语法： 函数对象（） 当调用函数时，函数中封装的代码会按照顺序执行 函数对象含有普通对象的一切功能（添加、删除、修改…..） 12var fun = new Function(\"console.log('这是一个函数');\");fun();//返回 这是一个函数 函数的参数定义一个用来求两个数的和的函数 可以在函数的（）中来指定一个或多个形参（形式参数） 多个形参之间用，隔开，声明形参就相当于在函数内部声明了对应的变量,但是并没有赋值 1234function sum(a,b)&#123; console.log(a+b);&#125;sum(1,2);//实参将会赋值给函数中对应的形参（a=1,b=2）,返回值是3 在调用函数时可以在（）中指定实参 实参将会赋值给函数中对应的形参 调用函数时解析器不会检查实参的类型 所以要注意，是否有可能会接受到非法的参数，如果有可能则需要对参数进行类型的检查 函数的实参可以是任意的数据类型 12345function sum(a,b)&#123; console.log(a+b);&#125;sum(123,\"hello\");//返回值为\"123hello\"sun(true,false);//返回值为1 调用函数时，解析器也不会检查实参的数量 多余的实参不会被赋值 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined 12345function sum(a,b)&#123; console.log(a+b);&#125;sum(123,456,\"hello\",true,false);//仍返回的是579sum(123);//输出NaN 函数的返回值可以使用return来设置函数返回值 语法：return 值; return后的值将会作为函数的执行结果返回，可以定义一个变量来接收该结果 变量result的值就是函数的执行结果，函数返回什么result的值就是什么 在函数中return后的语句都不会执行 如果return语句后不跟任何值，就相当于返回一个undefined 如果函数中不写return，则会返回undefined return后可以跟任意数据类型的值 123456function sum(a , b ，c)&#123; var d = a + b + c; return d;&#125;var result = sum(4,7,8);//将return的值赋给了resultconsole.log(result);//输出19 只要使用了return就会结束整个函数，不论return有多深，函数中return后的函数都不执行 实参可以是任何值 实参可以是任意的数据类型，也可以是一个对象 当我们的参数过多时，可以将参数封装到一个对象，然后通过对象传递 12345678910function xinxi(o)&#123; console.log(\"我是\"+o.name+\"，我今年\"+o.age+\"岁，我是\"+o.gender+\"人，家住在\"+o.address);&#125;var obj = &#123; name:\"孙悟空\", age:\"18\", gender:\"男\", address:\"花果山\"&#125;xinxi(obj);//输出 我是孙悟空，我今年18岁，我是男人，家住在花果山 函数就是一个对象，所以也可以作为参数 12345678910111213function xinxi(o)&#123; console.log(\"我是\"+o.name+\"，我今年\"+o.age+\"岁，我是\"+o.gender+\"人，家住在\"+o.address);&#125;var obj = &#123; name:\"孙悟空\", age:\"18\", gender:\"男\", address:\"花果山\"&#125;function fun(a)&#123; a(obj);&#125;fun(xinxi);//输出仍然是 我是孙悟空，我今年18岁，我是男人，家住在花果山 立即执行函数函数定义完，立即被调用，这种函数叫做立即执行函数， 立即执行函数往往只会执行一次 12345678(function()&#123; alert(\"我是一个匿名函数\");&#125;)();(function(a,b)&#123; console.log(a); console.log(b);&#125;)(123,456);//输出123456","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"js中的对象","slug":"js中的对象","date":"2020-05-12T13:32:31.000Z","updated":"2020-05-26T09:13:30.241Z","comments":true,"path":"2020/05/12/js中的对象/","link":"","permalink":"https://xingkai520.github.io/2020/05/12/js%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"js中的对象除了五种基本数据类型外还有一个引用数据类型：Object 对象(以后我们看到的值，只要不是五种基本数据类型的，全都是对象)","text":"js中的对象除了五种基本数据类型外还有一个引用数据类型：Object 对象(以后我们看到的值，只要不是五种基本数据类型的，全都是对象) 如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体，例如： 123var name = \"孙悟空\";var gender = \"男\";var age = \"18\";//这三个数据毫无关联，互相独立 Js中的变量都是保存到栈内存中的 基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响到其他变量 对象是保存在堆内存中，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个对象通过一个变量修改属性时，另一个也会受影响 当给其中一个对象赋值时，会切断与之前地址的连接 当比较两个两个基本数据类型时，就是比较的值，而比较两个引用数据类型时，是比较对象的内存地址，如果两个对象的值是一模一样的，但地址不同，也会返回false 对象属于一种复合的数据类型，在对象中可以保存多个不同类型的属性 对象的分类 1.内建对象 由ES标准中定义的对象，在仍何的ES实现中都可以使用，如：Math String Number Boolean…… 2.宿主对象 由JS的运行环境提供的对象，目前主要是指由浏览器提供的对象，如：BOM DOM 3.自定义对象 由开发人员自己创建的对象 ps:对象就像一个塑料袋！！ 自定义对象 创建对象 1、使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数 12var obj = new Object();console.log(typeof obj);//返回Object 在对象中保存的值称为属性，向对象中添加属性 语法：对象.属性名 = 属性值; 1234var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性 2、使用对象字面量来创建一个对象（使用对象字面量可以在创建对象时，直接指定对象中的属性） 对象字面量的属性名可以加引号也可以不加引号，建议不加。 如果要使用一些特殊的名字则必须加引号“！@￥#@……” 语法：{属性名：属性值，属性名：属性值，…..} 1234567891011var obj = &#123;&#125;;console.log(typeof obj);//输出objectobj.name = \"孙悟空\";console.log(obj.name);//输出孙悟空var obj2 = &#123; name:\"猪八戒\", age:28, gender:\"男\" &#125;;console.log(obj2);//输出 猪八戒 28 男 3、使用工厂方法创建对象 通过该方法可以大批量的创造对象 使用工厂方法创建的对象使用的构造函数都是Object，所以创建的对象都是Object这个类型，就导致我们无法区分出多个不同类型的对象 12345678910111213141516function createPerson(name , age , gender) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function () &#123; alert(this.name) &#125; return obj;&#125;var obj2 = createPerson(\"猪八戒\" , 28 , \"男\");var obj3 = createPerson(\"沙和尚\" , 28 , \"男\");var obj4 = createPerson(\"唐僧\" , 38 , \"男\");console.log(obj2);//输出猪八戒obj4.sayName();//输出唐僧 构造函数 可以创建一个构造函数专门用来创建person对象的，构造函数就是一个普通的含数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写 构造函数和普通函数的区别就是调用方式的不同 普通函数是直接调用，而构造函数需要使用new关键字来使用 构造函数的执行流程 1.立刻创建一个新的对象 2.将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建对象 3.逐行执行函数中的代码 4.将新建的对象作为返回值返回 使用同一个同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 123456function Person()&#123; this.name\"孙悟空\"&#125;var per = new Person();console.log(per)//输出不在是Object&#123;孙悟空&#125;而是person&#123;孙悟空&#125;console.log(per instanceof person);//使用instanceof可以检查一个对象是否是一个类的实例，是true，否false，所有的对象都是Object的后代，所以检查是否是Object类时全是true 读取对象中的属性 语法：对象.属性名 如果读取对象中没有的属性不会报错，会返回undefined 123456var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性console.log(obj.name);//输出孙悟空console.log(obj.hello);//输出undefined 修改对象的属性值 语法：对象.属性名 = 新值 123456var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性obj.name = \"齐天大圣\";console.log(obj.name);//输出齐天大圣 删除对象的属性 语法：delete 对象.属性名 123456var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性delete obj.name;console.log(obj.name);//输出undefined 属性名和属性值 属性名： 对象的属性名不强制要求遵守标识符的规范,什么名字都可以使用，但是使用时尽量按照标识符的规范去做 如果要使用特殊的属性名（如123等数字），不能采用.的方式来操作，需要使用另一种方式 语法：对象[“属性名”] = 属性值 1234567891011var obj = new Object();obj.var = \"hello\";//添加一个var属性console.log(obj.var);//输出helloobj.123 = 789;//报错obj[\"123\"] = 789;console.log(obj[\"123\"]);//输出789obj[\"！#￥%……&amp;#&amp;*&amp;%*&amp;\"] = \"这就是我\";console.log(obj[\"！#￥%……&amp;#&amp;*&amp;%*&amp;\"]);//输出 这就是我；尽量别这样 使用[]这种形式去操作属性，更加的灵活。 在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性 1234567var obj = new Object();obj[\"123\"] = 789;obj[\"nihao\"] = \"你好\";var n = \"123\";console.log(obj[n]);//输出789n = \"nihao\";console.log(obj[n]);//输出 你好 属性值 JS对象的属性值可以是任意的数据类型 1234567891011var obj = new Object();obj.test = \"hello\";console.log(obj.test);//输出helloobj.test = 123;console.log(obj.test);//输出123obj.test = true;console.log(obj.test);//输出trueobj.test = null;console.log(obj.test);//输出nullobj.test = undefined;console.log(obj.test);//输出undefined 甚至也可以是一个对象（套娃）、函数 如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法 调用函数就说调用对象的方法(method) 但是它只是名称上的区别没有其他的区别 1234567891011121314151617181920212223242526var obj = new Object();var obj2 = new Object();obj2.name = \"猪八戒\";obj.test = obj2;console.log(obj);//输出&#123; test: &#123; name: '猪八戒' &#125; &#125; console.log(obj.test);//输出&#123; name: '猪八戒' &#125;console.log(obj.test.name);//输出“猪八戒”var obj = Object();obj.name = \"孙悟空\";obj.age = \"18\";obj.sayName = function()&#123; console.log(obj.name);&#125;;obj.sayName();//输出孙悟空obj.sayName = function()&#123; console.log(obj.name);&#125;;function fun()&#123; console.log(obj.name);&#125;;obj.sayName();//调方法 //只是名称的区分，本质是一样的fun();//调函数 in运算符 通过该运算符可以检查一个对象中是否含有指定的属性 如果有则返回true，没有则返回false 语法： “属性名” in 对象 检查obj中是否含有test2的属性: 12345678910var obj = new Object();var obj2 = new Object();obj2.name = \"猪八戒\";obj.test = obj2;console.log(obj);//输出&#123; test: &#123; name: '猪八戒' &#125; &#125; console.log(obj.test);//输出&#123; name: '猪八戒' &#125;console.log(obj.test.name);//输出“猪八戒”console.log(\"test2\" in obj);//obj没有test2的属性 输出falseconsole.log(\"test\" in obj);//obj有test的属性 输出trueconsole.log(\"name\" in obj);//obj有name的属性 输出true 枚举对象中的属性枚举对象中的属性 使用for…in语句 for…in语句 对象中有几个属性，循环体就会执行几次 每次执行时会将对象中一个属性的名字赋值给变量 123456789101112131415//语法for(var 变量 in 对象)&#123;&#125;var obj = &#123; name:\"孙悟空\", age:18, gender:\"男\" address:\"花果山\" &#125;;for(var n in obj)&#123; console.log(\"hello\");//输出四次hello，因为obj对象中只有三个属性 console.log(n);//输出name age gender address console.log(obj[n]);//输出孙悟空 18 男 花果山&#125; 原型prototype我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 如果函数作为普通函数调用prototype没有任何作用 当函数以构造函数的形式调用时，他所创建的对象中都会有一个隐含得属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 当我们访问对象的一个属性或方法时，他会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果有会直接使用 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，作用不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了 1234567891011121314151617function MyClass()&#123; &#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;MyClass.prototype.sayName = function()&#123; alert(\"hello\")&#125;var mc = new MyClass();var mc2 = new MyClass();console.log(mc.__proto__ == MyClass.prototype);//输出trueconsole.log(mc.a);//输出123mc.a = \"我是mc中的a\";console.log(mc.a);//输出我是mc中的aconsole.log(mc2.a);//输出123mc.sayName();//输出hellomc2.sayName();//输出hello","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"git基础","slug":"git基础","date":"2020-05-09T02:08:52.000Z","updated":"2020-05-09T02:54:58.188Z","comments":true,"path":"2020/05/09/git基础/","link":"","permalink":"https://xingkai520.github.io/2020/05/09/git%E5%9F%BA%E7%A1%80/","excerpt":"git是什么？ git是一个非常优秀的版本控制系统，两个作用： 1）版本控制 2）协作开发 协作开发也是基于版本控制 git是用来管理你写的代码的。","text":"git是什么？ git是一个非常优秀的版本控制系统，两个作用： 1）版本控制 2）协作开发 协作开发也是基于版本控制 git是用来管理你写的代码的。 之前写代码模式： 创建一个文件夹 在这个文件夹下开始写代码 之前写代码的模式缺点： 1）没有版本 开发一个项目 v1 v2 v3 v4 2）不好管理 不好维护 团队协作开发时 -————————————git历史？ 大家自己百度一下 -————————————现在版本控制系统有哪些？ 1）svn 集中式版本控制系统 2）git 分布式版本控制系统 -————————————集中式版本控制系统？ 代表就是SVN 有点out了 就不讲了 只有一个远程的代码仓库，所有的程序员都维护这一个代码仓库。 不足： 1）如果远程仓库挂了，所有的版本都没有了 2）svn推送或拉取最新版本是基于文件传输的，速度比较慢一点 3）所有的版本都存储在远程仓库，每个程序员手头只有最新的版本，没有历史版本，进行版本管理时，不太好管理 -————————————分布式版本控制系统？ 代表就是git 现在用的非常多 在公司中每天都会用到 每一个程序员电脑上都有一个仓库，叫它为本地仓库。 优点： 1）如果远程仓库挂了，程序员手头还有所有的版本，数据不会丢失 2）是基于文件流进行传输的，速度快一点 3）所有程序员手头都所有的版本，代码管理起非常方便 -————————————github 和 git 有什么区别？ 1）git是一个管理代码的工具 2）github是一个网站 可以充当一个远程仓库 这个网址是程序员的聚集地 -————————————安装git这个工具： 直接百度搜索git 找到官网 下载这个工具 安装是傻瓜式安装 一路下一步 下一步就OK了 在使用git bash here时，你在哪个文件夹下点击了，它会自动定位到这个文件夹 -————————————安装完后，还需要告诉git你是谁？ 答：就是配置用户名和邮箱 最好是你先去注册一个github账号 注册完github账号后，你就有用户名和邮箱了 git config –global user.name “wangcai” git config –global user.email “1234567890@qq.com“ 设置用户名和邮箱只需要做一次就OK了。 -————————————常用的linux命令： ls 罗列出当前文件夹下面都有哪些文件或目录 mkdir css 表示在当前目录下面创建一个css文件夹 touch index.html 表示创建一个index.html文件 cd css 表示进入到css文件夹中 可以按tab键自动补全 cd .. 表示回到上一级目录 pwd 查看当前处理哪个目录下面（得到全路径） clear 清屏 rm index.html 表示删除一个文件 rmdir css 表示删除一个空的文件夹 ….. -————————————本地仓库： 一个空的文件夹，并不是一个本地仓库。 如何得到一个本地仓库呢？ 答：通过一个命令就可以得到本地仓库，叫git init 如果在一个文件夹（xxx）中通过git init命令创建出来了一个.git隐藏文件夹，那么这个文件夹(xxx)就是一个本地仓库了。 -————————————一个本地仓库是由几块区域组成： 1）工作区(.git之外的区域) 2）.git .git里面又包含两块区域 一块叫暂存区 一块叫历史区 .git文件夹，任何时候都不要动 写代码都在工作区进行写代码。 -————————————工作区： 就是程序员写代码的区域 只在工作区写代码 并不能形成版本 只有把代码扔到历史区，才能形成版本，但是你还不能直接把工作区的代码扔到历史区，你需要先把代码扔到暂存区，然后再从暂存区扔到历史区，形成版本。 -————————————查看历史区都有哪些版本？ 答：git log -————————————git常用命令： 1）git init 初始化一个本地仓库 2）git add * 把工作区的代码扔到暂存区 3）git commit -m ‘xx’ 把暂存区的代码扔到历史区形成一个版本 4）git log 查看历史区都有哪些版本 -————————————查看文件状态： git status 红色：代表当前工作区的文件并没有扔到暂存区 绿色：代表没有把暂存区的文件扔到历史区 -————————————回滚： 回到之前的版本 git reset –hard HEAD^ 表示回到上一个版本 HEAD^^表示回到上上一个版本 -————————————查看带有回滚的历史区版本的信息： 之前git log，只能查看当前历史区的版本，不带回滚的信息 现在git reflog，可看带有回滚版本的信息 -————————————总结： 1）git init 初始化本地仓库 2）配置用户名和邮箱 git config –global user.name “wangcai” git config –global user.email “1234567890@qq.com“ 3）git add 4）git commit -m “xx” 5）git log / git reflog 6）git reset –hard HEAD^/id 后悔药 7）git status 红色 绿色 什么分布式 什么是集中式-————————————","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://xingkai520.github.io/tags/git/"}]},{"title":"js中一些常用的语句","slug":"js中一些常用的语句","date":"2020-04-29T10:01:00.000Z","updated":"2020-05-12T13:33:26.259Z","comments":true,"path":"2020/04/29/js中一些常用的语句/","link":"","permalink":"https://xingkai520.github.io/2020/04/29/js%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5/","excerpt":"一些常用的Js语句","text":"一些常用的Js语句 prompt() prompt()可以弹出一个提示框，该提示框会带有一个文本框，用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数，该字符串会作为提示框的提示文字 用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容 函数的返回值为string函数 1var a = prompt(\"请输入小明的成绩：\"); document.write(); document.write()，可以向网页中输出一段文字 拼接字符串，用加号”+”，字符串用双引号””括起来。 1234567document.write(1);//在网页中输出1var a = 123;document.write(a);//网页中输出123var a = \"双胞胎哥哥\";document.write(a + \"双胞胎弟弟\");//输出:双胞胎哥哥双胞胎弟弟 console.time(); console.time(“计时器的名字”)可以开启一个计时器 他需要一个字符串作为参数，这个字符串将会作为计时器的标识 console.timeEnd(“计时器的名字”)用来停止一个计时器，需要一个计时器的名字作为参数 123456789101112131415console.time(\"test\");var num , a , b , c;for(num = 2 ; num &lt;= 100 ; num ++)&#123; c = 0; for(a = num ; a &gt; 1 ; a --)&#123; b = num % a; if(b == 0)&#123; c++; &#125; &#125; if(c == 1)&#123; document.write(num + \"&lt;br&gt;\"); &#125;&#125;console.timeEnd(\"test\"); Math.sqrt()可以通过Math.sqrt对一个数字进行开方 1Math.sqrt(36);//返回值为6","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"流程控制语句","slug":"流程控制语句","date":"2020-04-29T09:01:00.000Z","updated":"2020-05-12T06:36:59.855Z","comments":true,"path":"2020/04/29/流程控制语句/","link":"","permalink":"https://xingkai520.github.io/2020/04/29/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","excerpt":"流程控制语句 Js中的程序是从上到下一行行执行的 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行 语句的分类： 1、条件判断语句 2、条件分支语句 3、循环语句","text":"流程控制语句 Js中的程序是从上到下一行行执行的 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行 语句的分类： 1、条件判断语句 2、条件分支语句 3、循环语句 条件判断语句使条件判断语句可以在执行某个语句之前进行判断，如果条件成立才会执行语句，条件不成立则语句不执行。 if语句 语法一： ​ if(条件表达式) { ​ 语句….. ​ } if语句在执行时会先对条件表达式进行求值判断，如果条件表达式的值为true，则执行if后的语句。如果条件表达式的值为false则不会执行if后的语句 if语句只能控制紧随其后的语句，如果希望if语句控制多个语句可以将这些语句统一放到代码块里面 if后的一条语句时不需要加代码块，但是在开发中尽量写上代码块，即使if后面只有一条语句，结构更清楚 1234567891011121314151617181920212223242526272829if(true) alert(\"你猜我出来吗？\");//执行弹出文字if(false) alert(\"你猜我出来吗？\");//不执行var a = 10;if(a &gt; 10) alert(\"a比10大\");//不执行var a = 11;if(a &gt; 10) alert(\"a比10大\");//执行var a = 10;if(a &gt; 10) alert(\"a比10大\");//不执行 alert(\"管不到我！\");//执行var a = 10;if(a &gt; 10)&#123; alert(\"a比10大\");//不执行 alert(\"管不到我！\");//不执行&#125;var a = 15;if(a &gt; 10 &amp;&amp; a&lt;= 20) alert(\"a比10大且a小于20\");//不执行 语法二： ​ if(条件表达式) { ​ 语句….. ​ }else{ ​ 语句…… ​ } 当该语句执行时会对if后的条件表达式进行求值判断，如果为true则执行if后的语句，如果值为false则执行else后的语句 123456var a = 50;if(a&gt;60)&#123; console.log(\"你已经退休了\");&#125;else&#123; console.log(\"你还没退休\");&#125; 语法三： 123456if(条件表达式) &#123; 语句...... &#125;else if(条件表达式)&#123; 语句...... &#125;else if(条件表达式)&#123; 语句...... &#125;else 当该语句执行时会从上到下依次对条件表达式进行求值判断，如果值为true则执行当前语句，如果值为false则继续向下，如果条件都不满足则执行最后的else语句 该语句中只会有一个代码块被执行，一但代码块被执行了，则直接结束语句 1234567891011121314var a = 50;if(a &gt; 100)&#123; console.log(\"活着挺没意思\");&#125;else if(a &gt; 80)&#123; console.log(\"你也老大不小了\");&#125;else if(a &gt; 60)&#123; console.log(\"你该退休了\")&#125;else if(a &gt; 40)&#123; console.log(\"你已经中年了\")&#125;else if(a &gt; 18)&#123; console.log(\"你已经成年了\")&#125;else&#123; console.log(\"你还是个小孩\")&#125; 条件分支语句条件分支语句也叫作switch语句 switch语句语法 1234567891011121314switch(条件表达式)&#123; case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; &#125; 执行流程： switch…case…语句在执行时依次将case后的表达式的值和switch后的条件表达式的值进行全等比较 如果比较结果为true，则从当前case处开始执行代码，当前case后的所有代码都会执行，所以语句后面需要break;这样可以确保只执行当前case后的语句，而不会执行其他的case 如果比较结果为false，则继续向下比较。 如果所有的比较结果都为false则执行default后面的语句 12345678910111213141516171819202122232425var a = 1;switch(a)&#123; case 1: console.log(\"壹\") break; case 2: console.log(\"贰\") break; case 3: console.log(\"叁\") break; default: console.log(\"非法数字\") break;&#125;var a = 1;switch(true)&#123; case a &gt;= 60: console.log(\"及格\") break; default: console.log(\"不合格\") break;&#125; 循环语句通过循环语句可以反复执行一段代码多次 while循环 语法： 123while(条件表达式)&#123; 语句...; &#125; while语句在执行时，先对条件表达式进行求值判断，如果值是true，则执行循环体，循环体执行完毕后，继续对表达式进行判断，如果为true则继续执行循环体，循环此操作……..直到条件表达式判断为false则停止循环 1234var n = 1;while(true)&#123; alert(n++);&#125;//不停的弹出自增的数字；这样的叫做死循环，该循环不会停止除非关闭浏览器，开发慎用 可以用break跳出循环 1234567var n = 1;while(true)&#123; alert(n++); if(n&gt;10)&#123; break;//跳出循环 &#125;&#125; 创建一个循环，往往需要三个步骤 1234567891011//1、初始化一个变量var i = 0;//2、在循环中设置一个条件表达式while(i &lt; 10)&#123; alert(1);&#125;//3、定义一个更新表达式，每次更新初始化变量while(i &lt; 10)&#123; alert(i); i++;&#125; do…while循环 语法： 123do&#123; 语句...；&#125;while(条件表达式) 执行流程： do…while语句在执行时，会先执行循环体，循环体执行完以后，在对while后面的条件表达式进行判断，如果结果为true则继续执行循环体，如果结果为false则终止循环 实际上这两个语句相似，不同的是while是先判断再执行，do…while是先执行再判断（do…while可以保证循环体至少执行一次） for循环在for循环中，为我们提供了专门的位置来放三个表达式： 1、初始化表达式 2、条件表达式 3、更新表达式 语法： 1234567for(初始化表达式;条件表达式;更新表达式)&#123; 语句... &#125; for(var i = 0 ; i &lt; 10 ; i++)&#123; alert(i);&#125; 执行流程 1.执行初始化表达式，初始化变量。（初始化表达式只能执行一次） 2.执行条件表达式，判断是否执行循环，如果为true则执行循环，如果为false则终止循环。 3.执行更新表达式，更新表达式执行完毕继续重复第二步 for循环中的三个部分都可以省略，也可以写在外部 123456789var i = 0;for(;i&lt;10;)&#123; alert(i++);&#125;//循环输出10次for(;;)&#123; \"hello\"&#125;//死循环输出hello 终止break break关键字可以用来退出switch或循环语句(不能在裸if语句中使用) break关键字会立即终止离他最近的那个循环语句 123456789101112for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); break;&#125;for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); if(i&gt;5)&#123; break;//此时break作用于外部的for &#125;&#125; 可以为外循环创建一个label，来标识当前的循环 label:循环语句 使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的 12345678outer:for(var i=0 ; i&lt;10 ; i++)&#123; document.write(@i); for(var j=0 ; j&lt;10 ; j++)&#123; document.write(i); break outer;//直接结束外部循环 &#125; &#125; continue continue关键字可以跳过当次循环 continue只能用于循环语句 同样continue也是默认对离他最近的循环起作用 123456for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); if(i == 5)&#123; continue;//输出了除了5的小于10的正整数（跳过了i=5的本次循环） &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"上传博客图片无法显示问题","slug":"上传博客图片无法显示问题","date":"2020-04-23T09:25:29.000Z","updated":"2020-04-23T09:36:00.231Z","comments":true,"path":"2020/04/23/上传博客图片无法显示问题/","link":"","permalink":"https://xingkai520.github.io/2020/04/23/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/","excerpt":"上传博客无法引用本地图片问题","text":"上传博客无法引用本地图片问题 ## 1.下载插件 首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 123npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save或npm install hexo-asset-image --save 2.要将要引入的图片放入与md文件同名的文件夹中在下载插件完成之后再git bush中输入hexo n “text”可生成一个新的md文件和同名文件夹，将你要引入的图片放入这个文件夹内引用 3.在引入图片时不能使用Markdown语法引入不能使用 1![](img&#x2F;img.png) 应使用 1&#123;% asset_img 图片.jpg 图片描述 %&#125; 例如： 使用 1![](img&#x2F;img.png) 可以在本地看到图片但上传至hexo中看不到图片,使用 1&#123;% asset_img 图片.jpg 图片描述 %&#125; 能让你上传至hexo的文章中看到图片但在本地看不到。 我是为了本地观察方便也将写入其中，但不影响上传","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://xingkai520.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"viewport","slug":"viewport","date":"2020-04-23T08:26:09.000Z","updated":"2020-04-23T09:36:39.197Z","comments":true,"path":"2020/04/23/viewport/","link":"","permalink":"https://xingkai520.github.io/2020/04/23/viewport/","excerpt":"viewport的属性","text":"viewport的属性 1width=device-width 视口的宽度 通常设置成device-width(设备自身的宽度) 1initial-scale=1 设置页面的初始缩放值 1maxinum-scale=1.0 允许用户的最大缩放值 是一个数字 可以是小数 1mininum-scale=1.0 允许用户的最小缩放值 是一个数字 可以是小数 1user-scalable=no user-scalable : 用户是否可以手动缩放，值可以是：①yes、 true允许用户缩放；②no、false不允许用户缩放 1viewport-fit: cover; 应对留海屏幕的填充问题 (1) inital-scale也是用来设置视口的，前面说了，width是用来设置视口，其实有这样一个公式，如下： 视口 = 设备独立像素宽度 / inital-scale 可以通过inital-scale间接地设置视口，操作如下： 现在不让inital-scle是1，设置成2，如下： 那假如我把inital-scale=0.5，效果如下： 此时，我们设置视口，就有两种方式，如下： 12width=device-wdithinital-scale = 1 如果有一个人，它设置了width=device-wdith，又设置了inital-scale = 1，以谁为主。如果说你这样设置了，不放大，也不缩小，如下： 如果这样设置，如下： 则以最大的为主：","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Javascript基础","slug":"javascript基础","date":"2020-04-22T12:28:30.000Z","updated":"2020-05-20T08:46:24.251Z","comments":true,"path":"2020/04/22/javascript基础/","link":"","permalink":"https://xingkai520.github.io/2020/04/22/javascript%E5%9F%BA%E7%A1%80/","excerpt":"Javascript基础","text":"Javascript基础 ### **基本知识：** 控制浏览器弹出一个警告框 1alert(\"帅帅帅\") 让浏览器在界面中输出一个内容(向body中输出一个内容) 1document.write(\"你好！！！\") 向控制台输出一个内容 1console.log(\"控制台你好！！！\") 可以将js代码写到标签的onclick属性中。不方便维护，不推荐使用。 1&lt;button onclick=\"alert('点我干嘛--');\"&gt;点我点我&lt;/button&gt; 可以将js代码写在超链接的href属性中，这样当点击超链接时会执行js代码（前面必须加上JavaScript：） 1&lt;a href=\"javascript:alert('让你点你就点-_-!');\"&gt;也点我点我&lt;/a&gt; 一般是写在js文件中用以下代码连接 1&lt;script type=\"text/javascript\" src=\"./js/index.js\"&gt;&lt;/script&gt; 一但这个script标签用于引入外部js文件，那么这个script标签再编写代码将被浏览器忽略 如果需要则需要再写一个script标签 执行顺序从上到下执行 字面量 都是一些不可改变的量 比如：1 2 3 4 5。字面量都是可以直接使用的，如下 1alert(2132146489); 字面量都是可以直接使用，但是我们一般都不会直接使用字面量 变量变量可以用来保存字面量，而且变量的值是可以任意改变的 变量更加方便使用，所以在开发中都是通过变量去保存一个字面量 很少直接使用字面量 声明变量：在js中使用var关键字来声明一个变量 1var a; 需要给变量赋值 1a = 123; 可以声明和赋值同时进行 1var b = 846815; 变量声明提前 使用var关键字声明的变量，会在所有的代码执行之前被声明(但是不会赋值) 但是声明变量时不使用var关键字，则变量不会被声明提前 函数的声明提前 使用函数声明形式创建的函数function函数(){} 他会在所有的代码执行之前就被创建，所以这种方式写的函数可以在函数声明前来调用 使用函数表达式创建的函数，不会被声明提前 1234567891011121314151617a = 123;console.log(a);//输出 a = 123;console.log(a);//输出 a=undefined 没有报错var a = 123;console.log(a);//报错a = 123;fun();//输出我是一个fun函数fun2();//报错function fun()&#123; console.log(\"我是一个fun函数\");&#125;var fun2 = function()&#123; console.log(\"我是fun2函数\");&#125; 标识符在js中所有的可以由我们自主命名的都可以称为是标识符 例如：变量名、函数名、属性名都属于标识符 命名一个标识符时需要遵守如下的规则： 1.标识服中可以含有字母、数字、_、$ 2.标识符不能以数字开头 3.标识符不能是ES中的关键字或保留字 4.标识符一般采用驼峰命名法（首字母小写，每个开头字母大写，其余字母小写。不强制要求，但是是个好习惯） 5.JS底层保存标识符时实际上是采用Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符 6.var只在声明变量时使用，在后续需要修改时不需要再重复给一个变量var 12345678var a_1$ = 3;var var = 3；//不能这样helloWorld xxxYyyZzz//驼峰命名法var 我最帅 = 384;//可以用，但是不推荐这样用，不符合行业规范var str1 = 1;str1 = 2;//最后命名的变量值有效 数据类型数据类型指的就是字面量的类型 在JS中一共有六种数据类型： String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中String Number boolean Null Undefined属于基本数据类型，而Object属于引用数据类型 用法 String 字符串 在Js中字符串需要使用引号引起来 单引号和双引号都可以用没区别，但是不要混着用 不要在双引号中放双引号 可以在单引号中用双引号 在字符串中我们可以使用\\作为转义字符，当表示一些特殊符号时可以使用\\转义 1234567891011var str = \"hello\";console.log(str);var str = 'hello\"; //不要混着用var str = \"我说：\"今天天气真不错！\"\";//这样不对，会把”我说：“看做一个变量var str = '我说：\"今天天气真不错！\"';//这样可以var str = \"我说：\\\"今天天气真不错！\\\"\";//这样也可以，让里面的双引号仅仅代表双引号\\' 表示 ’\\\" 表示 \"\\n 表示换行\\t 制表符 \\\\ 表示\\ 我转义我自己 Number 数值 在JS中所有数值都是Number类型，包括整数和浮点数（小数） 数字123和字符123完全不同 可以使用一个typeof来检查一个变量类型 typeof+变量 JS中可以表示数字的最大值：Number.MAX_VALUE 可以用Number.MAX_VALUE*Number.MAX_VALUE，取最大值的平方 如果超过了最大值则会输出Infinity，表示正无穷；-Infinity表示负无穷 用两个字符串相乘：abc*bcd会输出NaN；NaN是一个特殊的数字，表示Not a number（不是数字） 使用typeof检查NaN会返回number Number.MIN_VALUE的值为0以上的最小值0.000000….. 在Js中整数的运算基本可以保证精确 如果使用JS进行浮点元素的计算，可能的到一个不精确的解果；因为二进制无法精确1/10; 可以把后面的数字给省略掉，但前提是不能涉及到钱，所以不要用JS计算精确度要求比较高的运算 1234567891011121314var a = 123;//数字123var b = \"123\";//字符123console.log(typeof a)//检查字符串时，会返回string；检查数值时，会返回numberconsole.log(Number.MAX_VALUE);a = Number.MAX_VALUE*Number.MAX_VALUE;//会输出Infinity，a = \"abc\"*\"bcd\"//输出NaNconsole.log(typeof a)//会输出numbera = Number.MIN_VALUEconsole.log(a)//输出5e-324var c = 1234456 + 4894894;//输出结果正确var c = 0.1 + 0.2;//输出结果为0.30000000000000000004 Boolean 布尔值 布尔值只有两个：true、false；真、假。主要用来做逻辑判断 true：表示真 false：表示假 使用typeof检查会输出boolean 123var bool = ture;console.log(bool);//输出为trueconsole.log(typeof bool)//输出为boolean Null类型的值只有一个，就是Null null（空值）专门用来表示为空的对象 使用typeof检查null会返回Object Undefined（未定义）类型的值只有一个，就是Undefined 当声明一个变量，但是不给变量赋值时，他的值就是Undefined 12345var a = null;console.log(a);//输出就是nullconsole.log(typeof a);//输出是Objectvar b = undefined;console.log(typeof b);//输出是undefined 其他进制数字 在js中如果需要表示16进制的数字，则需要以0x开头 如果要表示8进制的数字，则需要以0开头 如果要表示2进制的数字，则需要以0b开头，但是不是所有的浏览器都支持 输出的时候会转换为10进制输出 1234567//16进制var a = 0x10;console.log(a);//输出为16//8进制var a = 070;console.log(a);//输出为56 强制类型转换 指讲一个数据类型强制转换为其他的数据类型 类型转换主要指，将其他的数据类型，转换为：String、Number、Boolean 将其他的数据类型转换为String 方式一 调用被转换数据类型的toString()方法 该方法不会影响到原变量，会将转换的结果返回 但是要注意Null和Undefined这两个值没有toString方法，如果用这个方法调用会报错 方式二 调用String()函数，并将被转换的数据作为参数传递给函数 String（）函数做强制类型转换时对于Number和Boolean实际上就是调用toString()方法 但对于Null和Undefined，就不会和toString（）一样，他会将Null和Undefined直接转换为字符串“Null”和“Undefined” 将其他数据类型转换为Number 没有toNumber方式 方式一 使用Number()函数 1.如果是纯数字的字符串，则将其转换为数字 2.如果字符串中有非数字的内容，则转换为NaN 3.如果字符串为空串或者是一个全空格的字符串，则转换为数字0 4.true转换成数字1，false转换成数字0，Null转换成数字0，Undefined转换为NaN 方式二 这种方式专门用来对付字符串 parseInt（）把一个字符串转换为一个整数 可以将一个字符串中有效的整数内容取出来然后转换为Number，只读到从左到右第一个不为数字的地方 parseFloat（）把一个字符串转换为一个浮点数（小数） 可以将一个字符串的有效的小数取出，如果有两个小数点，则读到第二个小数点前 如果对String使用parseFloat（）、parseInt（），他会将其先转换为string，然后再操作 将其他数据类型转换为Boolean类型 方式 使用Boolean（）函数 数字转Boolean，除了0和NaN其余的都是true 字符串转Boolean，除了空串其余的都是true Null与Undefined转换为Boolean，都是false 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//将其他的数据类型转换为String//方式一：var a = 123;console.log(typeof a);//输出为Numberconsole.log(a);//输出为123a.toString();//调用a的toString()方法console.log(typeof a);//输出仍为Numbervar b = a.toString();console.log(typeof b);//输出为Stringconsole.log(b);//输出为123a = a.toString();//可以赋值给自己console.log(typeof a);//输出为Stringconsole.log(a);//输出为123a = true;a = toString();console.log(typeof a);//输出为Stringconsole.log(a);//输出为truea = Null;a = toString();//报错a = Undefined;a = toString();//报错//方式二：var a = 123;String(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123a = 123;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为123a = Null;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为Nulla = Undefined;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为Undefined//将其他数据类型转换为Number：//方式1：var a = \"123\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"abc\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = true;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为1var a = false;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = Null;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = Undefined;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaN//方式二：parseInt();var a = \"123px\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"123px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"123a564px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"a123px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"123.456px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = 123.456;parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123,可以用来取整//parseFloat();var a = \"123.456px\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123.456var a = \"123.456.789px\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123.456var a = \"true\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaN//转换其他进制时//转换8进制，这种字符串，有些浏览器（IE）会当成8进制解析，有些浏览器会当成10进制解析var a = 070;a = parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为56（或70）//可以在parseInt（）中传递第二个参数，来制定数字的进制var a = 070;a = parseInt(a,10);//把070当做10进制看console.log(typeof a);//输出为Numberconsole.log(a);//输出为70var a = 070;a = parseInt(a,8);//把070当做8进制看console.log(typeof a);//输出为Numberconsole.log(a);//输出为56//将其他数据类型转换为Boolean类型//数字转换为Boolean：var a = 123;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为truevar a = 0;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为falsea = -123;//truea = Infinity;//truea = NaN;//falsea = \"true\"//字符串转换为Boolean：var a = \"\";a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为false//Null与Undefined转换为Boolean：var a = Null;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为falsevar a = Undefined;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为false 运算符 运算符也叫作操作符 通过运算符可以对一个或多个值进行运算 比如：typeof就是运算符，可以用来获得一个值的类型，他会将该值的类型以字符串的形式返回 1234var a = 123;var result = typeof a;console.log(result);//输出numberconsole.log(typeof result);//输出string 算数运算符 +可以对两个值进行加法运算，并将值返回，如果对字符串进行加法操作则会对两个字符串做拼接处理，任何值和字符串做加法运算都是要将其转换成字符串然后再拼串处理；可以利用这一特点可以将任意类型的数据加一空串””就可以将这个数据类型变为字符串类型 -可以对两个值进行减法运算，并将值返回 *可以对两个值进行乘法运算，并将值返回 /可以对两个值进行除法运算，并将值返回 %取模运算（取余数） 对于非Number类型的值进行运算时，会将这些值转换成Number然后运算(除了加法)，可以通过给一个值-0，*1，/1,都可以转换为number类型 任何值和NaN做运算都得NaN 123456789101112131415161718192021222324252627282930313233343536var a = 1;var result;result = a + 1;//输出2result = true + 1;//输出2result = true + false;//输出1result = null + 1;//输出1result = NaN + 1;//输出NaNresult = \"123\" + \"456\";//输出123456；string类型result = \"你好\" + \"帅哥\";//输出你好帅哥；string类型var str = \"锄禾日当午，\" + //双引号必须在一行 \"汗滴禾下土。\" + \"谁知盘中餐，\" + \"粒粒皆辛苦。\";console.log(str);//输出锄禾日当午，汗滴禾下土。谁知盘中餐，粒粒皆辛苦。var c = 123;c = c + \"\";console.log(typeof c);//输出为stringconsole.log(c);//输出为123//减法：var result;result = 100 - \"1\";//输出99result = 2 * \"8\";//输出16var c = 123;c = c - 0;console.log(typeof c);//输出为numberconsole.log(c);//输出为123//取模：var a = 9 % 3;console.log(a);//输出为0var a = 9 % 4;console.log(a);//输出为1 一元运算符 一元运算符只需要一个操作数 +：正号 正号不会对数字产生任何影响，可以将其他类型转换为number类型 -：负号 负号可以对数字进行数字取反,对于非number值，先转换成number再进行取反 123456789101112131415161718192021222324252627var a = 123;a = +a;console.log(a);//输出为123var a = 123;a = -a;console.log(a);//输出为-123var a = true;a = -a;console.log(a);//输出为-1console.log(typeof a);//输出为numbervar a = \"123\";a = +a;console.log(a);//输出为123console.log(typeof a);//输出为numbervar a;a = 1 + \"2\" + 3;console.log(a);//输出为123console.log(typeof a);//输出为stringvar a;a = 1 + +\"2\" + 3;console.log(a);//输出为6console.log(typeof a);//输出为number 自增自减 自增：++ 通过自增可以使变量在自身的基础上增加1 对一个变量自增后，原变量会立即加1 自增分为两种:后++（a++）和前++（++a） 无论是a++还是++a都立即使原变量的值自增1 不同的是a++和++a的值不同 a++的值等于原变量的值（自增前的值） ++a的值等于原变量自增后的值 自减：”–” 通过自减可以使变量在自身的基础上减1 对一个变量自减后，原变量会立即减1 自减分为两种:后”–”（a”–”）和前”–”（”–”a） 无论是a”–”还是”–”a都立即使原变量的值自减1 不同的是a”–”和”–”a的值不同 a”–”的值等于原变量的值（自减前的值） “–”a的值等于原变量自减后的值 1234567891011121314151617181920212223242526272829//自增：var a = 1;a++;console.log(a);//输出为2var a = 1;console.log(a++);//输出为1console.log(a);//输出为2var a = 1;++a;console.log(a);//输出为2var a = 1;console.log(++a);//输出为2console.log(a);//输出为2var a = 20;a = a++ + ++a +a;//20+22+22console.log(a);//输出为2//自减：与自加一样var b = 10;b--;console.log(b);//输出为9var b = 10;--b;console.log(a);//输出为9 逻辑运算符js中为我们提供了3种逻辑运算符 &amp;&amp;与 可以对符号两侧的值进行与运算，并返回结果 两个值中只要有一个值为false就返回false，两个都是true才能返回true JS中的“与“属于短路的与，如果第一个值为false就不再看后面的值 ||或 可以对符号两侧的值进行或运算，并返回结果 只要有一个true就返回true JS中的“或“属于短路的或，如果第一个值为true就不再看后面的值 ！非 可以对一个值进行非运算 就是对一个布尔值进行取反操作 如果对一个非布尔值进行运算，则会将其转换为布尔值然后取反 可以利用这个特点将其他类型转换为布尔值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//&amp;&amp;与var result = true &amp;&amp; true;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = false &amp;&amp; false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; alert(\"你看我出不出来！！\");//运行弹出\"你看我出不出来！！\"var result = false &amp;&amp; alert(\"你看我出不出来！！\");//运行没有弹出\"你看我出不出来！！\"//||或var result = false || false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = true || false;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true || true;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; alert(\"你看我出不出来！！\");//运行没有弹出\"你看我出不出来！！\"var result = false &amp;&amp; alert(\"你看我出不出来！！\");//运行弹出\"你看我出不出来！！\"//!非var a = true;a = !a;console.log(a);//输出为falsevar a = true;a = !!a;console.log(a);//输出为truevar a = 10;a = !a;console.log(a);//输出为falseconsole.log(typeof a);//输出为Booleanvar a = 10;a = !!a;console.log(a);//输出为trueconsole.log(typeof a);//输出为Boolean 对于非布尔值进行与或运算时，会将其转换为布尔值，然后再运算，并且返回原值 与运算：如果第一个值为true，则直接返回第二个值，如果第一个值为false，则直接返回第一个值（找false） 或运算：如果第一个值为true，则直接返回第一个值，如果第一个值为false，则直接返回第二个值（找true） 12345678910111213141516171819202122232425262728293031323334//与：var a = 1 &amp;&amp; 2;console.log(a);//输出为2var a = 2 &amp;&amp; 1;console.log(a);//输出为1var a = 0 &amp;&amp; 1;console.log(a);//输出为0var a = 1 &amp;&amp; 0;console.log(a);//输出为0var a = NaN &amp;&amp; 0;console.log(a);//输出为NaNvar a = 0 &amp;&amp; NaN;console.log(a);//输出为NaN//或：var a = 2 || 1;console.log(a);//输出为2var a = 1 || 0;console.log(a);//输出为1var a = 1 || NaN;console.log(a);//输出为1var a = NaN || 1;console.log(a);//输出为1var a = NaN || 0;console.log(a);//输出为1 赋值运算符 =：可以将符号右侧的值赋值给符号左侧的变量 +=:a = a + 5等价于a = a + 5（+=不能分开写成+ =） -=:a = a - 5等价于a = a - 5（-=不能分开写成- =） =:a = a * 5等价于a = a * 5（=不能分开写成 * =） /=:a = a / 5等价于a = a / 5（/=不能分开写成/ =） %=:a = a % 5等价于a = a % 5（%=不能分开写成% =） 1234567891011121314151617181920212223242526var a = 123;console.log(a);//输出为123var a = 10;a = a + 5;console.log(a);//输出为15var a = 10;a += 5;console.log(a);//输出为15var a = 10;a -= 5;console.log(a);//输出为5var a = 10;a *= 5;console.log(a);//输出为50var a = 10;a /= 5;console.log(a);//输出为2var a = 10;a %= 5;console.log(a);//输出为0 关系运算符 通过关系运算符可以比较两个值之间的关系，如果关系成立则返回true，不成立则返回false “&gt;”判断左侧关系是否大于右侧，若大于则立即返回true，如果关系不成立则返回false “&gt;=”判断左侧关系是否大于或等于右侧，若大于或等于则立即返回true，如果关系不成立则返回false “==”判断左右是否相等，相等返回true，不相等返回false，NaN不和任何值比较包括他本身，可以用函数isNaN()来判断一个值是否是NaN “===”全等 和相等类似，但是他不会做自动转换，如果两个值类型不同直接返回false “！==”不全等 和不等类似，但是他不会做自动转换，如果两个值类型不同直接返回true “!=”判断左右是否相等，不相等返回true，相等返回false “&lt;=”判断左侧关系是否小于或等于右侧，若小于或等于则立即返回true，如果关系不成立则返回false “&lt;”判断左侧关系是否小于右侧，若小于则立即返回true，如果关系不成立则返回false 对于非数值类型判断，则先将其转化为数值类型再判断 任何数和NaN比都是false 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较，而是比较的Unicode编码，一位一位的对位比较，所以可以借用这个方法对英文进行排序，比较中文没有意义，对于两个字符串的数字比较一定要转型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var a = 5 &gt; 10;console.log(a);//输出为falsevar a = 5 &gt; 4;console.log(a);//输出为truevar a = 5 &gt; 5;console.log(a);//输出为falsevar a = 5 &gt;= 5;console.log(a);//输出为truevar a = 1 &gt; true;console.log(a);//输出为falsevar a = 1 &gt;= true;console.log(a);//输出为falsevar a = 1 &gt; \"0\";console.log(a);//输出为truevar a = 1 &gt; NaN;console.log(a);//输出为false，任何数和NaN比都是falsevar a = true &gt; false;console.log(a);//输出为truevar a = \"5\" &lt; \"11\";console.log(a);//输出为truevar a = \"11\" &lt; \"5\";console.log(a);//输出还是truevar a = \"11\" &lt; +\"5\";console.log(a);//输出还是falsevar a = \"a\" &lt; \"b\";console.log(a);//输出是truevar a = \"b\" &lt; \"a\";console.log(a);//输出是falsevar a = \"abc\" &lt; \"b\";console.log(a);//输出是true，一位一位进行比较var a = \"bbc\" &lt; \"b\";console.log(a);//输出是false，一位一位进行比较var a = \"b\" &lt; \"a\";console.log(a);//输出是falsevar a = NaN == NaN;console.log(a);//输出是falsevar a = NaN;console.log(isNaN(a));//输出是true 条件运算符 条件运算符又叫三元运算符：”条件表达式?语句1:语句2” 条件运算符在执行时，首先对条件表达式进行求值 如果该值为true则执行语句1，并返回执行结果0 如果该值为false则执行语句2，并返回执行结果 如果条件表达式的求值结果是一个非布尔值，会将其转化为布尔值，然后再运算 1234567891011121314151617181920212223242526272829303132true?alert(\"语句1\"):alert(\"语句2\");//执行语句1false?alert(\"语句1\"):alert(\"语句2\");//执行语句2var a = 10;var b = 20;a &gt; b ? alert(\"a大\"):alert(\"b大\");//b大//获取a和b中的最大值var a = 10;var b = 20;var max = a &gt; b ? a : b; console.log(max)//输出b//获取a和b、c中的最大值var a = 10;var b = 20;var c = 50;var max = a &gt; b ? a : b; max = max &gt;c ? max : c;console.log(max)//输出cvar a = 10;var b = 20;var c = 50;var max = a &gt; b ? a &gt; c ? a : c : b &gt; c ? b : c; //a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c); 不推荐使用，不方便阅读console.log(max)//输出50\"hello\"?alert(\"语句1\"):alert(\"语句2\");//执行语句1\"\"?alert(\"语句1\"):alert(\"语句2\");//执行语句2 运算符的优先级 , 运算符：使用，可以分割多个语句，一般可以在声明多个变量时使用（用的最多） 12var a , b , c;var a = 1 , b = 2 , c = 3; 和数学中一样，JS中运算符也有优先级 先乘除后加减 12var result = 1 + 2 * 3;console.log(result)//输出7 &amp;&amp;的优先级比||高 在Js中有一个运算优先级的表，在表中越靠上优先级越高，优先级高的优先计算，如果优先级一样高，则从左到右计算，这个表不需要硬记，如果遇到优先级不清楚的，用（）分开 12var result = 1 || 2 &amp;&amp; 3;console.log(result)//输出1 Unicode编码在字符串中使用转义字符输入unicode编码，\\u+四位编码 12console.log(\"\\u0031\");//输出1console.log(\"\\u2620\");//输出☠（骷髅头） 要在网页中使用Unicode编码 123&lt;h1&gt; &amp;#编码&lt;!--这里的编码需要的是10进制--&gt;&lt;/h1&gt; 代码块（语句） 我们的程序就是由一条条语句构成的 执行的时候从上到下执行 用{}为语句分组 同一个{}我们称为一组语句，要么都执行要么都不执行。也叫作代码块，在}=后不用加； Js中的代码块只有分组的作用没有其他的作用 1elert(\"hello\");//这就是语句 注意 js中严格区分达小写 js中每一条语句以分号结尾（如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，有些时候浏览器会加错分号，所以在开发中必须加分号） js会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 注释多行注释/**/ 单行注释//","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://xingkai520.github.io/tags/Javascript/"}]},{"title":"移动端视口适配","slug":"视口移动端适配","date":"2020-04-16T11:13:58.000Z","updated":"2020-04-23T09:36:28.950Z","comments":true,"path":"2020/04/16/视口移动端适配/","link":"","permalink":"https://xingkai520.github.io/2020/04/16/%E8%A7%86%E5%8F%A3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","excerpt":"移动端视口适配","text":"移动端视口适配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@media screen and (min-width:320px) &#123; html &#123; font-size: 21.33px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:360px) &#123; html &#123; font-size: 24px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:375px) &#123; html &#123; font-size: 25px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:384px) &#123; html &#123; font-size: 25.6px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:400px) &#123; html &#123; font-size: 26.67px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:414px) &#123; html &#123; font-size: 27.6px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:424px) &#123; html &#123; font-size: 28.27px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:480px) &#123; html &#123; font-size: 32px &#125; body &#123; font-size: 15.36px &#125;&#125;@media screen and (min-width:540px) &#123; html &#123; font-size: 36px &#125; body &#123; font-size: 17.28px &#125;&#125;@media screen and (min-width:720px) &#123; html &#123; font-size: 48px &#125; body &#123; font-size: 23.04px &#125;&#125;@media screen and (min-width:750px) &#123; html &#123; font-size: 50px &#125; body &#123; font-size: 24px &#125;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"写博客基础","slug":"我的第一个博客","date":"2020-04-05T12:40:00.000Z","updated":"2020-05-09T01:26:28.964Z","comments":true,"path":"2020/04/05/我的第一个博客/","link":"","permalink":"https://xingkai520.github.io/2020/04/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","excerpt":"Markdown的一些基本语法","text":"Markdown的一些基本语法 **1）标题** 一级标题二级标题三级标题四级标题五级标题六级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 ==2）字体== 加粗 倾斜 ==高亮== 删除线 我是^上标^ 我是下标 1234567891011**加粗***倾斜*&#x3D;&#x3D;高亮&#x3D;&#x3D;~~删除线~~我是^上标^我是~下标~ ==3）列表== 第一级实心圆（按tab换级） 第二级空心圆 第三级实心方框 第四级及之后都是实心方框 按回车取消本级 有序列表 英文状态下的1. 按回车自动添加表头数字 再按回车取消本行 1234567891011+ 第一级实心圆（按tab换级） + 第二级空心圆 + 第三级实心方框 + 第四级及之后都是实心方框按回车取消本级1. 有序列表2. 英文状态下的1.3. 按回车自动添加表头数字4. 再按回车取消本行 ==4）表格== mon tue wed thu 哈哈 哈哈哈 哈哈哈哈 哈哈哈哈哈 啦啦 啦啦啦 啦啦啦啦 啦啦啦啦啦 1234| mon | tue | wed | thu || ---- | ------ | -------- | ---------- || 哈哈 | 哈哈哈 | 哈哈哈哈 | 哈哈哈哈哈 || 啦啦 | 啦啦啦 | 啦啦啦啦 | 啦啦啦啦啦 | ==5）引用== 一级引用 再加&gt;变为二级引用 以此类推 按回车取消一级 1234567&gt; 一级引用&gt;&gt; &gt;再加&gt;变为二级引用&gt; &gt;&gt; &gt;&gt; 以此类推&gt; &gt;&gt;&gt; &gt;&gt; &gt; 按回车取消一级 ==6）分割线== 1-------- ==7）代码== 代码块 12代码块​```+语言 代码 12&#96;代码&#96;","categories":[],"tags":[{"name":"Markdown常用语法","slug":"Markdown常用语法","permalink":"https://xingkai520.github.io/tags/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}]},{"title":"标题","slug":"模板","date":"2020-04-05T12:40:00.000Z","updated":"2020-05-14T06:08:54.380Z","comments":true,"path":"2020/04/05/模板/","link":"","permalink":"https://xingkai520.github.io/2020/04/05/%E6%A8%A1%E6%9D%BF/","excerpt":"标题","text":"标题","categories":[],"tags":[{"name":"标签","slug":"标签","permalink":"https://xingkai520.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"},{"name":"git","slug":"git","permalink":"https://xingkai520.github.io/tags/git/"},{"name":"博客","slug":"博客","permalink":"https://xingkai520.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://xingkai520.github.io/tags/Javascript/"},{"name":"Markdown常用语法","slug":"Markdown常用语法","permalink":"https://xingkai520.github.io/tags/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"name":"标签","slug":"标签","permalink":"https://xingkai520.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}