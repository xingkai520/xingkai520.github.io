{"meta":{"title":"Hexo","subtitle":"","description":"","author":"xingkai","url":"https://xingkai520.github.io","root":"/"},"pages":[],"posts":[{"title":"html小结","slug":"html小结","date":"2020-07-07T11:50:30.000Z","updated":"2020-07-07T11:52:06.217Z","comments":true,"path":"2020/07/07/html小结/","link":"","permalink":"https://xingkai520.github.io/2020/07/07/html%E5%B0%8F%E7%BB%93/","excerpt":"html小结 一，HTML是什么1，什么是HTML？ 超文本标签语言 什么是超文本？ 文字，图片，视频，音频，程序，链接…. 问：html本身是纯文本还是超文本？ 答：本身是纯文本","text":"html小结 一，HTML是什么1，什么是HTML？ 超文本标签语言 什么是超文本？ 文字，图片，视频，音频，程序，链接…. 问：html本身是纯文本还是超文本？ 答：本身是纯文本 二，HTML的基本语法1，HTML的基本骨架？12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; .... &lt;/body&gt;&lt;/html&gt; 2，HTML的标签的分类 结构：html head body title meta文章：hn p br em storng超链接：a图片：img配合布局：div span列表类：ul+li ol+li dl+dt+dd表格类：table+tr+th+td+thead+tbody表单类：form input select+option textaarea浮动框架：iframe 3，HTML的基本语法1.语法非常松散2.不区分大小写3.对于单标签 最后的/ 可加可不加4.属性可以不加引号 4，书写HTML的好习惯1.必须写上HTML的基本骨架2.标签全部使用小写3.属性名不加引号，属性值加上引号（在JS中单引号和双引号是一样的）4.标签可以嵌套，但是不能交叉5.一定要正确的结束标签 三，HTML中的基本标签1，标题标签 hn headline场景：1）新闻/文章…一级标签 2）首页logo 2，段落标签 p paragraph场景：一个段落 有时候需要配合br标签来用 3，超连接标签 a anchor场景：超连接 文字 图片分类：站内连接 站外连接 锚点连接 其它连接路径：相对路径 和 绝对路径 ./ ../target: _self _blank 4，图片标签 img image（插入图）场景：网页上的图片（网页上的图片也可能是背景图）路径：相对路径 和 绝对路径 ./ ../alt: 1）… 2）… 5，DIV 和 SPAN 男标签：独占一行 hn p div 列表类 表格类女标签：并排显示 a span strong em i b人妖标签：并排显示 img input 四，列表相关的标签1，无序列表 用的非常多导航也会使用无序列表轮播图….. 五，表格相关的标签 也是在特别的地方使用表格也是可以布局的现在表格布局已淘汰 CSS布局 六，表单相关的标签 表单：form 标签表单元素：inputselect+optiontextarea 七，浮动框架 iframe 引用第三方 八，其它标签 emstrong","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://xingkai520.github.io/tags/html/"}]},{"title":"BOM","slug":"BOM","date":"2020-06-03T11:19:13.000Z","updated":"2020-07-07T11:48:02.118Z","comments":true,"path":"2020/06/03/BOM/","link":"","permalink":"https://xingkai520.github.io/2020/06/03/BOM/","excerpt":"","text":"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"DOM","slug":"DOM","date":"2020-06-03T11:18:58.000Z","updated":"2020-07-08T08:53:58.982Z","comments":true,"path":"2020/06/03/DOM/","link":"","permalink":"https://xingkai520.github.io/2020/06/03/DOM/","excerpt":"什么是DOM DOM全称Document Object Model文档对象模型 Js中通过DOM来对HTML文件进行操作，只要理解DOM就可以随心所欲的操作WEB页面 文档 文档表示的就是整个HTMl网页文档 对象 对象表示将网页中的每一个部分都转换为了一个对象 模型 使用模型来表示对象之间的关系，这样方便我们获取对象","text":"什么是DOM DOM全称Document Object Model文档对象模型 Js中通过DOM来对HTML文件进行操作，只要理解DOM就可以随心所欲的操作WEB页面 文档 文档表示的就是整个HTMl网页文档 对象 对象表示将网页中的每一个部分都转换为了一个对象 模型 使用模型来表示对象之间的关系，这样方便我们获取对象 模型HTML DOM 模型被结构化为对象树： 节点 节点Node ,是构成我们网页的最基本的组成部分,网页中的每一个部分都可以称为是一个节点。 比如: html标签、属性、文本、注释、整个文档等都是一个节点。 虽然都是节点,但是实际上他们的具体类型是不同的。 比如:标签我们称为元素节点、属性称为属性节点、文本称为文本节点、文档称为文档节点。 节点的类型不同,属性和方法也都不尽相同。 常用节点分为四类： 文档节点：整个HTML文档 元素节点：HTML文档中的HTML标签 属性节点：元素的属性 文本节点：HTML标签中的文本内容 浏览器已经为我们提供了文档节点，对象这个对象是window属性可以在页面中直接使用，文档节点代表的是整个网页 获取/修改对象 123456789&lt;body&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; //获取到button对象 var btn = document.getElementById(\"btn\");//输出“我是一个按钮”按钮 //修改按钮的文字 btn.innerHTML = \"按钮\";//输出“按钮”按钮 &lt;/script&gt;&lt;/body&gt; 事件 事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。 JavaScript与HTML之间的交互式通过事件实现的 对于web来说，有下面这些代表性的事件：点击某个元素、将鼠标移动至某个元素上方，按下键盘上某个按键，等等。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 我们可以在事件对应的属性中设置一些js代码， 这样当事件被触发时，这些代码将会执行 这种写法我们称为结构和行为耦合，不方便维护，不推荐使用 --&gt; &lt;!--&lt;button id=\"btn\" onmousemove=\"alert('讨厌，你点我干嘛！');\"&gt;我是一个按钮&lt;/button&gt;--&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; /* * 事件，就是用户和浏览器之间的交互行为， * 比如：点击按钮，鼠标移动、关闭窗口。。。 */ //获取按钮对象 var btn = document.getElementById(\"btn\"); /* * 可以为按钮的对应事件绑定处理函数的形式来响应事件 * 这样当事件被触发时，其对应的函数将会被调用 */ //绑定一个单击事件 //像这种为单击事件绑定的函数，我们称为单击响应函数 btn.onclick = function()&#123; alert(\"你还点~~~\"); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 例举一些事件的用法 onload 为window绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 浏览器在加载一个页面时，是按照自上向下的顺序加载的， * 读取到一行就运行一行,如果将script标签写到页面的上边， * 在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载 * 会导致无法获取到DOM对象 */ /* * onload事件会在整个页面加载完成之后才触发 * 为window绑定一个onload事件 * 该事件对应的响应函数将会在页面加载完成之后执行， * 这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了 * */ window.onload = function()&#123; //获取id为btn的按钮 var btn = document.getElementById(\"btn\"); //为按钮绑定一个单击响应函数 btn.onclick = function()&#123; alert(\"hello\"); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;点我一下&lt;/button&gt; &lt;!--&lt;script type=\"text/javascript\"&gt; /* * 将js代码编写到页面的下部就是为了，可以在页面加载完毕以后再执行js代码 */ //获取id为btn的按钮 var btn = document.getElementById(\"btn\"); //为按钮绑定一个单击响应函数 btn.onclick = function()&#123; alert(\"hello\"); &#125;; &lt;/script&gt;--&gt; &lt;/body&gt;&lt;/html&gt; 获取元素节点 通过document对象调用 1、getElementById() —通过id属性获取一个元素节点对象 2、getElementByTagName()—通过标签名获取一组元素节点对象 3、getElementByName() —通过name属性获取一组元素节点对象 通过具体的元素节点调用 1、getElrmentsByTagName()—方法，返回当前节点的指定标签名后代节点 2、childNodes —属性，表示当前节点的所有子节点 3、firstChild —属性，表示当前节点的第一个子节点 4、lastChild —属性，表示当前节点的最后一个子节点 获取父节点和兄弟节点 通过具体的节点调用 1、parentNode —属性，表示当前节点的父节点 2、previousSibling —属性，表示当前节点的前一个兄弟节点 3、nextSibling —属性，便是当前节点的后一个兄弟节点 DOM查询一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style/css.css\" /&gt; &lt;script type=\"text/javascript\"&gt; /* * 定义一个函数，专门用来为指定元素绑定单击响应函数 * 参数： * idStr 要绑定单击响应函数的对象的id属性值 * fun 事件的回调函数，当单击元素时，该函数将会被触发 */ function myClick(idStr , fun)&#123; var btn = document.getElementById(idStr); btn.onclick = fun; &#125; window.onload = function()&#123; //为id为btn01的按钮绑定一个单击响应函数 var btn01 = document.getElementById(\"btn01\"); btn01.onclick = function()&#123; //查找#bj节点 var bj = document.getElementById(\"bj\"); //打印bj //innerHTML 通过这个属性可以获取到元素内部的html代码 alert(bj.innerHTML); &#125;; //为id为btn02的按钮绑定一个单击响应函数 var btn02 = document.getElementById(\"btn02\"); btn02.onclick = function()&#123; //查找所有li节点 //getElementsByTagName()可以根据标签名来获取一组元素节点对象 //这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中 //即使查询到的元素只有一个，也会封装到数组中返回 var lis = document.getElementsByTagName(\"li\"); //打印lis //alert(lis.length); //变量lis for(var i=0 ; i&lt;lis.length ; i++)&#123; alert(lis[i].innerHTML); &#125; &#125;; //为id为btn03的按钮绑定一个单击响应函数 var btn03 = document.getElementById(\"btn03\"); btn03.onclick = function()&#123; //查找name=gender的所有节点 var inputs = document.getElementsByName(\"gender\"); //alert(inputs.length); for(var i=0 ; i&lt;inputs.length ; i++)&#123; /* * innerHTML用于获取元素内部的HTML代码的 * 对于自结束标签，这个属性没有意义 */ //alert(inputs[i].innerHTML); /* * 如果需要读取元素节点属性， * 直接使用 元素.属性名 * 例子：元素.id 元素.name 元素.value * 注意：class属性不能采用这种方式， * 读取class属性时需要使用 元素.className */ alert(inputs[i].className); &#125; &#125;; //为id为btn04的按钮绑定一个单击响应函数 var btn04 = document.getElementById(\"btn04\"); btn04.onclick = function()&#123; //获取id为city的元素 var city = document.getElementById(\"city\"); //查找#city下所有li节点 var lis = city.getElementsByTagName(\"li\"); for(var i=0 ; i&lt;lis.length ; i++)&#123; alert(lis[i].innerHTML); &#125; &#125;; //为id为btn05的按钮绑定一个单击响应函数 var btn05 = document.getElementById(\"btn05\"); btn05.onclick = function()&#123; //获取id为city的节点 var city = document.getElementById(\"city\"); //返回#city的所有子节点 /* * childNodes属性会获取包括文本节点在呢的所有节点 * 根据DOM标签标签间空白也会当成文本节点 * 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点， * 所以该属性在IE8中会返回4个子元素而其他浏览器是9个 */ var cns = city.childNodes; //alert(cns.length); /*for(var i=0 ; i&lt;cns.length ; i++)&#123; alert(cns[i]); &#125;*/ /* * children属性可以获取当前元素的所有子元素 */ var cns2 = city.children; alert(cns2.length); &#125;; //为id为btn06的按钮绑定一个单击响应函数 var btn06 = document.getElementById(\"btn06\"); btn06.onclick = function()&#123; //获取id为phone的元素 var phone = document.getElementById(\"phone\"); //返回#phone的第一个子节点 //phone.childNodes[0]; //firstChild可以获取到当前元素的第一个子节点（包括空白文本节点） var fir = phone.firstChild; //firstElementChild获取当前元素的第一个子元素 /* * firstElementChild不支持IE8及以下的浏览器， * 如果需要兼容他们尽量不要使用 */ //fir = phone.firstElementChild; alert(fir); &#125;; //为id为btn07的按钮绑定一个单击响应函数 myClick(\"btn07\",function()&#123; //获取id为bj的节点 var bj = document.getElementById(\"bj\"); //返回#bj的父节点 var pn = bj.parentNode; alert(pn.innerHTML); /* * innerText * - 该属性可以获取到元素内部的文本内容 * - 它和innerHTML类似，不同的是它会自动将html去除 */ //alert(pn.innerText); &#125;); //为id为btn08的按钮绑定一个单击响应函数 myClick(\"btn08\",function()&#123; //获取id为android的元素 var and = document.getElementById(\"android\"); //返回#android的前一个兄弟节点（也可能获取到空白的文本） var ps = and.previousSibling; //previousElementSibling获取前一个兄弟元素，IE8及以下不支持 //var pe = and.previousElementSibling; alert(ps); &#125;); //读取#username的value属性值 myClick(\"btn09\",function()&#123; //获取id为username的元素 var um = document.getElementById(\"username\"); //读取um的value属性值 //文本框的value属性值，就是文本框中填写的内容 alert(um.value); &#125;); //设置#username的value属性值 myClick(\"btn10\",function()&#123; //获取id为username的元素 var um = document.getElementById(\"username\"); um.value = \"今天天气真不错~~~\"; &#125;); //返回#bj的文本值 myClick(\"btn11\",function()&#123; //获取id为bj的元素 var bj = document.getElementById(\"bj\"); //alert(bj.innerHTML); //alert(bj.innerText); //获取bj中的文本节点 /*var fc = bj.firstChild; alert(fc.nodeValue);*/ alert(bj.firstChild.nodeValue); &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"total\"&gt; &lt;div class=\"inner\"&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=\"city\"&gt; &lt;li id=\"bj\"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;p&gt; 你喜欢哪款单机游戏? &lt;/p&gt; &lt;ul id=\"game\"&gt; &lt;li id=\"rl\"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt; &lt;br /&gt; &lt;p&gt; 你手机的操作系统是? &lt;/p&gt; &lt;ul id=\"phone\"&gt;&lt;li&gt;IOS&lt;/li&gt; &lt;li id=\"android\"&gt;Android&lt;/li&gt;&lt;li&gt;Windows Phone&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class=\"inner\"&gt; gender: &lt;input class=\"hello\" type=\"radio\" name=\"gender\" value=\"male\"/&gt; Male &lt;input class=\"hello\" type=\"radio\" name=\"gender\" value=\"female\"/&gt; Female &lt;br&gt; &lt;br&gt; name: &lt;input type=\"text\" name=\"name\" id=\"username\" value=\"abcde\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"btnList\"&gt; &lt;div&gt;&lt;button id=\"btn01\"&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn02\"&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn03\"&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn04\"&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn05\"&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn06\"&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn07\"&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn08\"&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn09\"&gt;返回#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn10\"&gt;设置#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn11\"&gt;返回#bj的文本值&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; DOM查询二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; //获取body标签，获取的是一个伪数组 //var body = document.getElementsByTagName(\"body\")[0]; console.log(body); /* * 在document中有一个属性body，它保存的是body的引用 */ var body = document.body; /* * document.documentElement保存的是html根标签 */ var html = document.documentElement; //console.log(html); var html= document.getElementsByTagName(\"html\")[0] console.log(html); /* * document.all代表页面中所有的元素(现已被废弃) */ var all = document.all; console.log(all, all.length)//HTMLAllCollection(7) [html, head, meta, meta, title, body, script, viewport: meta] 7 /*for(var i=0 ; i&lt;all.length ; i++)&#123; console.log(all[i]); &#125;*/ //all = document.getElementsByTagName(\"*\"); //console.log(all.length); /* * 根据元素的class属性值查询一组元素节点对象 * getElementsByClassName()可以根据class属性值获取一组元素节点对象， * 但是该方法不支持IE8及以下的浏览器 */ //var box1 = document.getElementsByClassName(\"box1\"); //console.log(box1.length); //获取页面中的所有的div //var divs = document.getElementsByTagName(\"div\"); //获取class为box1中的所有的div //.box1 div /* * document.querySelector() * - 需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象 * - 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替 * - 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个 */ var div = document.querySelector(\".box1 div\"); var box1 = document.querySelector(\".box1\") console.log(div.innerHTML); console.log(box1.innerText);//我是box1中的div,我是box1中的div, //我是box1中的div console.log(box1.innerHTML);// 我是box1中的div,我是box1中的div, // &lt;div&gt;我是box1中的div&lt;/div&gt; /* * document.querySelectorAll() * - 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回 * - 即使符合条件的元素只有一个，它也会返回数组 */ box1 = document.querySelectorAll(\".box1\"); // box1 = document.querySelectorAll(\"#box2\"); console.log(box1); console.log(box1[0]); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"box1\"&gt; 我是第一个box1,我是box1中的div, &lt;div&gt;我是box1中的div&lt;/div&gt; &lt;/div&gt; &lt;div class=\"box1\"&gt; &lt;div&gt;我是box1中的div&lt;/div&gt; &lt;/div&gt; &lt;div class=\"box1\"&gt; &lt;div&gt;我是box1中的div&lt;/div&gt; &lt;/div&gt; &lt;div class=\"box1\"&gt; &lt;div&gt;我是box1中的div&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; DOM增删改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style/css.css\" /&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; //创建一个\"广州\"节点,添加到#city下 myClick(\"btn01\",function()&#123; //创建广州节点 &lt;li&gt;广州&lt;/li&gt; //创建li元素节点 /* * document.createElement() * 可以用于创建一个元素节点对象， * 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象， * 并将创建好的对象作为返回值返回 */ var li = document.createElement(\"li\"); //创建广州文本节点 /* * document.createTextNode() * 可以用来创建一个文本节点对象 * 需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回 */ var gzText = document.createTextNode(\"广州\"); //将gzText设置li的子节点 /* * appendChild() * - 向一个父节点中添加一个新的子节点 * - 用法：父节点.appendChild(子节点); */ li.appendChild(gzText); //获取id为city的节点 var city = document.getElementById(\"city\"); //将广州添加到city下 city.appendChild(li); &#125;); //将\"广州\"节点插入到#bj前面 myClick(\"btn02\",function()&#123; //创建一个广州 var li = document.createElement(\"li\"); var gzText = document.createTextNode(\"广州\"); li.appendChild(gzText); //获取id为bj的节点 var bj = document.getElementById(\"bj\"); //获取city var city = document.getElementById(\"city\"); /* * insertBefore() * - 可以在指定的子节点前插入新的子节点 * - 语法： * 父节点.insertBefore(新节点,旧节点); */ city.insertBefore(li , bj); &#125;); //使用\"广州\"节点替换#bj节点 myClick(\"btn03\",function()&#123; //创建一个广州 var li = document.createElement(\"li\"); var gzText = document.createTextNode(\"广州\"); li.appendChild(gzText); //获取id为bj的节点 var bj = document.getElementById(\"bj\"); //获取city var city = document.getElementById(\"city\"); /* * replaceChild() * - 可以使用指定的子节点替换已有的子节点 * - 语法：父节点.replaceChild(新节点,旧节点); */ city.replaceChild(li , bj); &#125;); //删除#bj节点 myClick(\"btn04\",function()&#123; //获取id为bj的节点 var bj = document.getElementById(\"bj\"); //获取city var city = document.getElementById(\"city\"); /* * removeChild() * - 可以删除一个子节点 * - 语法：父节点.removeChild(子节点); * * 子节点.parentNode.removeChild(子节点); */ //city.removeChild(bj); bj.parentNode.removeChild(bj); &#125;); //读取#city内的HTML代码 myClick(\"btn05\",function()&#123; //获取city var city = document.getElementById(\"city\"); alert(city.innerHTML); &#125;); //设置#bj内的HTML代码 myClick(\"btn06\" , function()&#123; //获取bj var bj = document.getElementById(\"bj\"); bj.innerHTML = \"昌平\"; &#125;); myClick(\"btn07\",function()&#123; //向city中添加广州 var city = document.getElementById(\"city\"); /* * 使用innerHTML也可以完成DOM的增删改的相关操作 * 一般我们会两种方式结合使用 */ //city.innerHTML += \"&lt;li&gt;广州&lt;/li&gt;\"; //创建一个li var li = document.createElement(\"li\"); //向li中设置文本 li.innerHTML = \"广州\"; //将li添加到city中 city.appendChild(li); &#125;); &#125;; function myClick(idStr, fun) &#123; var btn = document.getElementById(idStr); btn.onclick = fun; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"total\"&gt; &lt;div class=\"inner\"&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=\"city\"&gt; &lt;li id=\"bj\"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"btnList\"&gt; &lt;div&gt;&lt;button id=\"btn01\"&gt;创建一个\"广州\"节点,添加到#city下&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn02\"&gt;将\"广州\"节点插入到#bj前面&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn03\"&gt;使用\"广州\"节点替换#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn04\"&gt;删除#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn05\"&gt;读取#city内的HTML代码&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn06\"&gt;设置#bj内的HTML代码&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn07\"&gt;创建一个\"广州\"节点,添加到#city下&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 图片切换练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; #outer&#123; width: 500px; margin: 50px auto; padding: 10px; background-color: greenyellow; /*设置文本居中*/ text-align: center; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; /* * 点击按钮切换图片 */ //获取两个按钮 var prev = document.getElementById(\"prev\"); var next = document.getElementById(\"next\"); /* * 要切换图片就是要修改img标签的src属性 */ //获取img标签 var img = document.getElementsByTagName(\"img\")[0]; //创建一个数组，用来保存图片的路径 var imgArr = [\"img/1.jpg\" , \"img/2.jpg\" , \"img/3.jpg\" , \"img/4.jpg\" ,\"img/5.jpg\"]; //创建一个变量，来保存当前正在显示的图片的索引 var index = 0; //获取id为info的p元素 var info = document.getElementById(\"info\"); //设置提示文字 info.innerHTML = \"一共 \"+imgArr.length+\" 张图片，当前第 \"+(index+1)+\" 张\"; //分别为两个按钮绑定单击响应函数 prev.onclick = function()&#123; /* * 切换到上一张，索引自减 */ index--; //判断index是否小于0 if(index &lt; 0)&#123; index = imgArr.length - 1; &#125; img.src = imgArr[index]; //当点击按钮以后，重新设置信息 info.innerHTML = \"一共 \"+imgArr.length+\" 张图片，当前第 \"+(index+1)+\" 张\"; &#125;; next.onclick = function()&#123; /* * 切换到下一张是index自增 */ index++; if(index &gt; imgArr.length - 1)&#123; index = 0; &#125; //切换图片就是修改img的src属性 //要修改一个元素的属性 元素.属性 = 属性值 img.src = imgArr[index]; //当点击按钮以后，重新设置信息 info.innerHTML = \"一共 \"+imgArr.length+\" 张图片，当前第 \"+(index+1)+\" 张\"; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"outer\"&gt; &lt;p id=\"info\"&gt;&lt;/p&gt; &lt;img src=\"img/1.jpg\" alt=\"冰棍\" /&gt; &lt;button id=\"prev\"&gt;上一张&lt;/button&gt; &lt;button id=\"next\"&gt;下一张&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"css小结","slug":"CSS小结","date":"2020-06-03T11:18:58.000Z","updated":"2020-07-11T01:56:01.769Z","comments":true,"path":"2020/06/03/CSS小结/","link":"","permalink":"https://xingkai520.github.io/2020/06/03/CSS%E5%B0%8F%E7%BB%93/","excerpt":"@TOC css2总结什么是css？ CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一个","text":"@TOC css2总结什么是css？ CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一个 css语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 css常用选择器基本选择器1、id 选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 以下的样式规则应用于元素属性 id=”para1”: 12345678&lt;style&gt;#para1&#123; text-align:center; color:red;&#125;&lt;/style&gt;&lt;div id=\"paral\"&gt;id&lt;/div&gt; ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。!!!! 2、class 选择器 class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点”.”号显示： 在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。1234&lt;style&gt;.center &#123;text-align:center;&#125;&lt;/style&gt;&lt;div class=\"center\"&gt;class&lt;/div&gt; 3、标签选择器也叫类型选择器，或叫元素选择器 你也可以指定特定的HTML元素使用class。在以下实例中, 所有的 p 元素使用让该标签的文本居中:1234567&lt;style&gt;p.center &#123;text-align:center;&#125;&lt;/style&gt;&lt;p&gt;class&lt;/p&gt;&lt;p&gt;class&lt;/p&gt;&lt;p&gt;class&lt;/p&gt;&lt;p&gt;class&lt;/p&gt; 类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。！！！ 4、通配符选择器 使用通配符，*，表示所有的标签（元素）。 经典应用：使用*来去掉所有标签的margin和padding。1234*&#123;margin:0;padding:0;&#125; 高级选择器1、后代选择器 E F 后代选择器匹配到E元素下面的所有的F元素（包括子、孙），空格隔开。123456789&lt;style&gt;div ul li &#123;width:100px; height:100px;&#125;&lt;br&gt;//匹配到div下面的所有ul，且ul的所有后代li&lt;/style&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2、多元素选择器 E,F 多元素选择器同时匹配到E元素和F元素，用逗号隔开。12345&lt;style&gt;div,#box&#123;width:100px; height:100px; background:#000;&#125;//同时匹配到下文中的div标签和id为box的p标签&lt;/style&gt;&lt;div&gt;&lt;/div&gt;&lt;p id=\"box\"&gt;&lt;/p&gt; 3、伪类选择器（1）;link 匹配所有未被点击的链接1a:link&#123; color: green; &#125; （2）:hover 匹配鼠标悬停在其上的元素1a:hover&#123; color: gold; &#125; （3）:active 匹配鼠标按下还没有释放的元素1a:active&#123; color: blue; &#125; （4）:visited 匹配所有已经被点击的链接1a:visited&#123; color: red; &#125; 引入css文件的三种方式1、行内样式就是直接在标签的开始标签中，使用style属性，如图：2、内部样式 直接使用style标签来完成，注意，style标签要写在head部分，不要写到body里面了。在heed部分，添加style标签，如下：3、外部样式 分两步：① 将css作为一个独立的文件来保存，一般后缀.css② 使用link标签引入 css三大属性继承性 说明 因为css具有继承性，所以在可以body里面设置字体等此网页中常用的属性，这样可以极大程度的简化的编写。 继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。换句话说，就是特定的CSS属性向下传递到子孙元素。 举例 注意： 并不是所有的css属性都可以继承可以继承的常见属性有：font-family,font-size,font-style,font-weight,font, line-height,text-align,text-indent,color 层叠性 说明 层叠性是多种CSS样式的叠加，是浏览器处理样式冲突的方式。在HTML中对于同一个元素可以有多个CSS样式存在，当有相同权重的样式存在时，会根据这些样式出现的先后顺序来决定，处于最后面的CSS样式将会覆盖前面的CSS样式。 举例下面代码，出现一个div 标签指定了相同样式不同值的情况，这就是样式冲突。 123456div&#123; color:red;&#125;div&#123; color:blue;&#125; 规则 通常出现样式冲突，会按CSS书写的顺序，以最后的样式为准。样式不冲突，不会层叠。样式冲突，遵循就近原则。 长江后浪推前浪，后面样式盖前面。 优先级在复杂CSS样式表，往往并不是相同样式不同值的堆叠这么简单，经常出现两个或多个不同样式规则应用在同一元素上，这时到底采用哪个样式呢？这就是典型的CSS优先级问题。 处理优先级问题，就是考虑样式权重的高低。这里介绍一些特殊的情况： 1、继承样式的权重为0。也就是说，在嵌套结构中，无论父元素样式权重多大，子元素继承时，应用在子元素上的权重都为0，即子元素定义的样式会覆盖所有继承来的样式。 2、行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。 3、权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。 4、CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。 用权重计算css的优先级值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 总结优先级 !important&gt;行内样式&gt; ID 选择器&gt;类(伪元素、伪类、属性)选择器&gt;元素选择器&gt;通用选择器 1、使用了 !important声明的规则。2、内嵌在 HTML 元素的 style属性里面的声明。3、使用了 ID 选择器的规则。4、使用了类选择器、属性选择器、伪元素和伪类选择器的规则。5、使用了元素选择器的规则。6、使用了通配符的规则。7、同一类选择器则遵循就近原则。 css盒子模型 简介网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模型都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。内容区（content） 内容区是盒子模型的中心，它呈现了盒子的主要信息内容，这些内容可以是文本、图片等多种类型。内容区有三个属性，width、height 和overflow。使用width和height属性可以指定盒子内容区的高度和宽度。 填充（padding）填充是内容区和边框之间的空间。填充的属性有五种 ，即padding -toppadding -bottompadding -leftpadding-right以及综合了以上四种方向的快捷填充属性padding。使用这五种属性可以指定内容区信息内容与各方向边框间的距离。设置盒子背景色属性时，可使背景色延伸到填充区域。 边框（border）边框是环绕内容区和填充的边界。边框的属性有border-style、border-width和border-color 以及综合了以上三类属性的快捷边框属性 border。 border-style 属性是边框最重要的属性，如果没有指定边框样式，其他的边框属性都会被忽略，边框将不存在。CSS规定了dotted（点线）、dashed（虚线）、solid(实线)等九种边框样式。 使用border-width属性可以指定边框的宽度，其属性值可以是长度计量值，也可以是CSS规定的thin、medium 和thick。 使用border-color属性可以为边框指定相应的颜色，其属性值可以是rgb值，也可以是CSS 规定的17个颜色名 。 在设定以上三种边框属性时，既可以进行边框四个方向整体的快捷设置，也可以进行四个方向的专向设置，如border-top: 2px solid green 或border-top-style: solid、border-left-color: red等。 注意： 设置盒子背景色属性时，在IE中背景不会延伸到边框区域，但在FF等标准浏览器中，背景颜色可以延伸到边框区域，特别是单边框设置为点线或虚线时能看到效果 。 空白边（margin）空白边位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是CSS 布局的一个重要手段。 空白边的属性有五种 ，即margin-topmargin-bottommargin- leftmargin-right以及综合了以上四种方向的快捷空白边属性margin，其具体的设置和使用与填充属性类似。 对于两个相邻的（水平或垂直方向 ）且设置有空白边值的盒子，他们邻近部分的空白边将不是二者空白边的相加，而是二者的并集。若二者邻近的空白边值大小不等，则取二者中较大的值。 同时，CSS 容许给空白边属性指定负数值，当指定负空白边值时，整个盒子将向指定负值方向的相反方向移动，以此可以产生盒子的重叠效果。采用指定空白边正负值的方法可以移动网页中的元素，这是CSS 布局技术中的一个重要方法。 css元素分类在CSS中，html中的标签元素大体被分为三种不同的类型：块级元素、内联元素(又叫行内元素)和内联块状元素(又叫行内块元素) 元素分类–块级元素什么是块级元素？在html中&#60;div&#62; &#60;p&#62; &#60;hn&#62; &#60;from&#62; &#60;ul&#62; 和 &#60;li&#62; 就是块级元素。 设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。 1a&#123;display:block;&#125; 块级元素特点：1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 元素分类–内联元素（行内元素）在html中，&#60;span&#62; 、&#60;a&#62; 、&#60;lable&#62; 、 &#60;strong&#62; 和&#60;em&#62; 就是典型的内联元素（行内元素）（inline）元素。当然块级元素也可以通过代码display:inline将元素设置为内联元素（行内元素）。 如下代码就是将块状元素div转换为内联元素（行内元素），从而使 div 元素具有内联元素（行内元素）特点。 123456&lt;style&gt; div&#123; display:inline; &#125; &lt;/style&gt;&lt;div&gt;我要变成内联元素&lt;/div&gt; 内联元素特点：1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 元素分类–内联块状元素（行内块元素）内联块状元素（行内块元素（inline-block）就是同时具备内联元素、块级元素的特点，代码display:inline-block就是将元素设置为内联块状元素（行内块元素）。 &#60;img&#62;、&#60;input&#62;标签就是这种内联块状标签。inline-block 元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。可以通过修改display属性来切换块级元素和行内元素 css属性 css属性很多，但常用的基本就二十多个 1、边框修饰：border border——&gt;top，bottom，left，right上下左右边框分为：color，类型style{ groove，dashed，ridge，solid}一个值——-&gt;四个边 二个值——-&gt;上下 左右 三个值——-&gt;上 左右 下 四个值——–&gt;上 右 下 左(顺时针) 2、文字修饰：font color: red;/字体颜色font-size: 30px; /字体大小 默认字体大小是16pxfont-family: “微软雅黑”; /字体font-weight: bolder; /字体粗细 lighter normal boldfont-style: italic; /字体类型 3、文本修饰：text text-align: center; /文本对齐方式/left、righttext-decoration: underline; /文本描述text-indent: 20px; /em 字符单位 px像素单位/首行缩进text-indent: 2em; /2em在默认情况下是32pxtext-shadow: 5px 5px 2px yellow;/ 文本投影投影 水平距离 垂直 模糊程度 颜色 4、多行文本溢出隐藏 overflow: hidden;——&gt;/溢出隐藏text-overflow: ellipsis;——&gt; /溢出内容以省略号的形式显示 5、一行文本的溢出 overflow: hidden;/隐藏超出部分text-overflow: ellipsis;显示省略符号来代表被修剪的文本。div里面title属性可以隐藏文本。word-break：break-word——&gt;自动换行line-height——&gt;行高letter-spacing——&gt;字间距。text-align: justify;——&gt;两端分散对齐。text-align-last: justify;——&gt;最后一行两端分散对齐。 6、背景修饰：background background-color: red;——&gt;/背景颜色 默认值 transparentbackground-image:url(猫.jpg);——&gt;/背景图片 默认值none/背景图片优于背景颜色显示background-repeat: no-repeat;——&gt;/定义背景图片是否重复 默认值repeat repeat-(x/y)background-position:right 20px bottom 20px;——&gt;/ 写了一个方向的位置移动 另一个方向默认居中background-position: center;——&gt; /背景图片位置 默认left topbackground-size: 500px 500px;——&gt; /背景图片大小 7、盒子属性：margin值 盒子与盒子之间的距离 margin 0 auto水平居中 margin-top/bottom/right/leftpadding值“设置内容与边框的距离”一般{margin 0；padding 0；*重置盒子的自带属性值。**}边界溢出 第一个子元素的上边界 最后一个的下边界 溢出父元素。解决办法：height: 500px;/加高度第一种对象是父元素。overflow: hidden;/第二种padding: 1px;/第三种上下边界合并 取大值。 8、转换盒子属性： display: inline-block; /元素转为行内块元素display: block;/元素转为块级元素 9、颜色表示方法： 1、英文 不透明background: red;2、十六进制(兼容好) 不透明background: #ff0000;#+(0-9)(a-f)3、rgba 透明background: rgba(255,0,0,1);r 红色 0-255b 蓝色 0-255g 绿色 0-255a 透明度 0-1之间的小数 12、盒子自带属性： span,i{ 盒子属性失效 对行标签display: block; 行元素转换成块元素 13、浮动坍塌： 解决:子元素浮动了就给父元素加上。1.给父元素设置高度2.overflow:hidden;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xingkai520.github.io/tags/css/"}]},{"title":"正则","slug":"正则","date":"2020-06-01T10:53:27.000Z","updated":"2020-06-02T13:48:10.771Z","comments":true,"path":"2020/06/01/正则/","link":"","permalink":"https://xingkai520.github.io/2020/06/01/%E6%AD%A3%E5%88%99/","excerpt":"正则表达式 正则表达式用于定义一些字符串的规则 计算机可以根据正则表达式，来检查一个字符串是否符合规则 获取字符串中符合规则的内容提取出来","text":"正则表达式 正则表达式用于定义一些字符串的规则 计算机可以根据正则表达式，来检查一个字符串是否符合规则 获取字符串中符合规则的内容提取出来 创建正则表达式的对象 语法：var 变量 = new RegExp(“正则表达式”,”匹配模式”) test():用于检查一个字符串是否符合正则表达式的规则，符合返回true，不符合返回false 这个正则表达式可以来检查一个字符串中是否含有a 1234var reg = new RegExp(\"a\");var str = \"a\";console.log(reg);//输出/a/console.log(reg.test(\"sdafg\"));//输出true（只要有小写a就是true） 用字面量创建正则表达式，使用字面量创建正价简单，使用构造函数更加灵活 语法：var 变量 = /正则表达式/匹配模式 12var reg = /a/i;console.log(reg.test(\"sdAfg\"));//输出true 在构造函数中可以传递一个匹配模式作为第二个参数 可以是 i : 忽略大小写 ​ g ：全局匹配模式 12var reg = new RegExp(\"a\",\"i\");console.log(reg.test(\"sdAfg\"));//输出true 正则表达式的用法 检查一个字符串是否有a或b 12reg = new RegExp(\"a|b\",\"i\");console.log(reg.test(\"sdBfg\"));//输出true 检查一个字符串中是否含有字母 12reg = /[a-z]/i;console.log(reg.test(\"sdBfg\"));//输出true(区分大小写) 检查一个字符串中是否含有abc或adc或aec 12reg = /a[bde]c/i;console.log(reg.test(\"sabcg\"));//输出true(区分大小写) 除了^ 123reg = /[^ab]/;//(除了ab有其他的)console.log(reg.test(\"ab1\"));//输出true(区分大小写)reg = /[^0-9]/;//(除了数字有其他的) 将一个字符串拆分为一个数组 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符 123var str = \"1a2b3c4d5f6e7\";var result = str.split(/[A-z]/);console.log(result);//返回1,2,3,4,5,6,7 search() 可以搜索字符串中是否含有指定内容 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1 他可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 不能全局查找只会查找第一个，即使设计全局匹配也一样 123456var str = \"hello abc hello aec afc\";var result = str.search(\"abcd\");console.log(result);//返回-1result = str.search(\"abc\");console.log(result);//返回6comsole.log(str.search(/a[bef]c/));//返回6 match() 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 默认情况下我们的match只会找到第一个符合要求的内容，找到后就停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容 可以为一个正则表达式设置多个匹配模式，且顺序无所谓 match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 12345var str = \"1a2b3c4d5f6eABF\";var result = str.match(/[a-z]/g);console.log(result);//返回a,b,c,d,e,fresult = str.match(/[a-z]/ig);console.log(result);//返回a,b,c,d,e,f,A,B,F replace() 可以将字符串中指定内容替换为新内容 参数： 1.被替换内容，可以接受一个正则表达式作为参数 2.新的内容 默认只会替换第一个 12345var str = \"1a2a3a4d5f6eABF\";var result = str.replace(\"a\",\"@_@\");console.log(result);//返回1@_@2a3a4d5f6eABFvar result = str.replace(/a/g,\"@_@\");console.log(result);//返回1@_@2@_@3@_@4d5f6eABF 量词 通过量词可以设置一个内容出现的次数 量词只对前边的一个内容起作用 {n}正好出现n次 {m,n}出现m-n次 {m,}出现m次及以上 +表示至少一个，相当于{1,} *表示0个及以上，有没有都行 ？表示0或1个 12345678910111213141516var reg = /a&#123;3&#125;/;console.log(reg.test(\"aaabc\"));//返回truereg = /ab&#123;3&#125;/;console.log(reg.test(\"abbbc\"));//返回truereg = /(ab)&#123;3&#125;/;console.log(reg.test(\"abababbbc\"));//返回truereg = /(ab)&#123;1,3&#125;/;console.log(reg.test(\"ababccc\"));//返回truereg = /a&#123;3,&#125;/;console.log(reg.test(\"aaaaaaaaaabccc\"));//返回truereg = /ab+c/;console.log(reg.test(\"aabccc\"));//返回truereg = /ab*c/;console.log(reg.test(\"aaaaaaaaaabccc\"));//返回truereg = /ab?c/;console.log(reg.test(\"aaaaaaaaaabccc\"));//返回true 检查一个字符串是否以某个元素开头 ^表示开头 [^]表示除了 12var reg = /^a/;console.log(reg.test(\"abcabc\"));//返回true $表示结尾 1234var reg = /$a/;console.log(reg.test(\"abcabca\"));//返回truevar reg = /^a$/;//只能出现一个a，即开头的a也得是结尾的aconsole.log(reg.test(\"a\"));//返回true . 表示任意字符 如果要检测 . 则需要转义字符 \\ . 表示 . \\ \\表示\\ 在使用构造函数时，由于他的参数是字符转，而\\ 是转义字符，如果要用\\ 则要用\\ \\表示 1234567var reg = /./;console.log(reg.test(\"@#$%^\"));//返回truereg = /\\./;console.log(reg.test(\"@#$%^\"));//返回falsereg = new RegExp(\"\\\\.\");console.log(reg.test(\"!@$#^\"));//返回falseconsole.log(reg);//返回\\. \\字母代表的意思 \\w：任意字母、数字、_ \\W: 除了字母、数字、_ \\d：任意数字 \\D：除了数字 \\s：空格 \\S：除了空格 \\b：单词边界 \\B：除了单词边界(是否是一个独立的单词，也就是检查这个单词两边有没有空格) 12var reg = /child\\b/;console.log(reg.test(\"children\"));//false 去除字符串前后的空格 123var str = \" hel lo \";str = str.replace(/^\\s*|\\s*$/g,\"\");console.log(str);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"js基础练习题","slug":"js基础练习","date":"2020-05-28T12:18:31.000Z","updated":"2020-06-03T11:17:20.831Z","comments":true,"path":"2020/05/28/js基础练习/","link":"","permalink":"https://xingkai520.github.io/2020/05/28/js%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/","excerpt":"js基础练习题 乘法表 打印1-100中所有的质数 定义一个函数，判断一个数字是否是偶数，如果是则返回true，否则返回false 定义一个函数，可以根据半径计算一个圆的面积，并返回计算结果 数组练习,将其中岁数大于18的函数提取出来放入另一个数组中并返回 去除数组中重复的数字 创建一个正则表达式，用来检测一个字符是否是一个核合法机号 用正则表达式检测电子邮件格式","text":"js基础练习题 乘法表 打印1-100中所有的质数 定义一个函数，判断一个数字是否是偶数，如果是则返回true，否则返回false 定义一个函数，可以根据半径计算一个圆的面积，并返回计算结果 数组练习,将其中岁数大于18的函数提取出来放入另一个数组中并返回 去除数组中重复的数字 创建一个正则表达式，用来检测一个字符是否是一个核合法机号 用正则表达式检测电子邮件格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//乘法表 var a , b; for(a = 1 ; a &lt;= 9 ; a++)&#123; for(b = 1 ; b &lt;= a ; b++)&#123; document.write(b + \"*\" + a + \"=\" + a*b + \" &amp;nbsp\"); &#125; document.write(\"&lt;br&gt;\"); &#125;//打印1-100中所有的质数 console.time(\"test\"); var num , a , b , c; for(num = 2 ; num &lt;= 10000 ; num ++)&#123; c = 0; for(a = num ; a &gt; 1 ; a --)&#123; b = num % a; if(b == 0)&#123; c++; &#125; &#125; if(c == 1)&#123; document.write(num + \"&lt;br&gt;\"); &#125; &#125; console.timeEnd(\"test\");//打印1-100中所有的质数优化版 console.time(\"test\");//计时器 var num , a , b; for(num = 2 ; num &lt;= 10000 ; num ++)&#123; b = 0; for(a = num-1 ; a &gt;= Math.sqrt(num) ; a --)&#123; if(num % a == 0)&#123; b = 1; &#125; &#125; if(b == 0)&#123; document.write(num + \"&lt;br&gt;\"); &#125; &#125; console.timeEnd(\"test\");//定义一个函数，判断一个数字是否是偶数，如果是则返回true，否则返回false var a = prompt(\"输入一个数字：\"); function fun(a)&#123; return a % 2 == 0; &#125; document.write(fun(a));//定义一个函数，可以根据半径计算一个圆的面积，并返回计算结果 var r = prompt(r); function s()&#123; return r*r*3.1415926535; &#125; document.write(s(r))//数组练习,将其中岁数大于18的函数提取出来放入另一个数组中并返回function Person(name , age , gender)&#123; this.name = name; this.age = age;&#125;Person.prototype.toString = function()&#123; return \"姓名：\" + this.name + \"年龄：\" + this.age;&#125;var per = new Person(\"孙悟空\",18);var per2 = new Person(\"猪八戒\",28);var per3 = new Person(\"沙和尚\",19);var per4 = new Person(\"唐僧\",20);var per5 = new Person(\"白龙马\",8);var perArr = [per,per2,per3,per4,per5];var perArr2 = [];for(var i = 0 ; i &lt; perArr.length ; i++)&#123; if(perArr[i].age &gt;= 18)&#123; perArr2.push(perArr[i]); &#125;&#125;console.log(perArr);console.log(perArr2);//数组去重练习（也可以用for循环）var arr = new Array();var arr = [1, 2, 5, 7, 3, 4, 5, 6, 1, 2, 4, 2, 6, 3, 4, 4, 6];arr.forEach(function fun1(num1) &#123; var a = 0; arr.forEach(function fun2(num2, i) &#123; if (num1 == num2) &#123; a++; &#125; if (a &gt;= 2) &#123; arr.splice(i, 1); &#125; &#125;);&#125;);console.log(arr);//创建一个正则表达式，用来检测一个字符是否是一个核合法机号reg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(reg.test(\"1763085212\"));//用正则表达式检测电子邮件格式var reg = /^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/;console.log(reg.test(\"123abc@163.com\"));","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"垃圾回收","slug":"垃圾回收","date":"2020-05-27T03:41:35.000Z","updated":"2020-05-27T03:53:25.649Z","comments":true,"path":"2020/05/27/垃圾回收/","link":"","permalink":"https://xingkai520.github.io/2020/05/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"垃圾回收 就像人生活的时间长了会产生垃圾一样，程序运行过程也会产生垃圾 垃圾积攒过多以后，会导致程序运行速度过慢， 所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生的垃圾","text":"垃圾回收 就像人生活的时间长了会产生垃圾一样，程序运行过程也会产生垃圾 垃圾积攒过多以后，会导致程序运行速度过慢， 所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生的垃圾 当一个对象没有任何变量或属性对他进行引用时，此时我们将永远无法操作该对象 此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢；所以这种垃圾必须进行清理 在js中拥有自动回收垃圾的机制，会自动将这些垃圾对象从内存中销毁 我们不需要也不能进行垃圾回收操作 我们需要做的只是将不再使用的对象设置null即可 123var obj = new Object();(代码....)obj = null;//断开了obj和对象的连接，使对象没有被任何变量或属性对他引用，此时会自动销毁该对象","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"JS中的作用域（Scope）","slug":"JS中的作用域（Scope）","date":"2020-05-20T08:07:55.000Z","updated":"2020-05-20T09:35:05.726Z","comments":true,"path":"2020/05/20/JS中的作用域（Scope）/","link":"","permalink":"https://xingkai520.github.io/2020/05/20/JS%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Scope%EF%BC%89/","excerpt":"作用域 作用域指一个变量的作用范围 在JS中有两种作用域 1.全局作用域 2.函数作用域","text":"作用域 作用域指一个变量的作用范围 在JS中有两种作用域 1.全局作用域 2.函数作用域 全局作用域 直接编写在script标签中的js代码，都在全局作用域 全局作用域在页面打开时创建，在页面关闭时销毁 在全局作用域中，有一个全局对象window，我们可以直接使用 ​ 他代表的是一个浏览器端口，他由浏览器创建，可以直接在浏览器中使用 在全局作用域中， ​ 创建的变量都会作为window对象的属性保存 ​ 创建的函数都会作为window对象的方法保存 全局作用域中的变量都是全局变量 ​ 在页面的任意部分都可以访问的到 1234567891011console.log(window);//输出 [object window]var a = 10;console.log(window.a);//输出 10function fun()&#123; console.log(\"我是fun函数\");&#125;window.fun()//输出 我是fun函数window.alert(\"hello\");//输出hello 函数作用域 调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁 每调用一次函数都会创建一个新的函数作用域，他们之间是相互独立的 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量 当在函数作用域中操作一个变量时，他会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中找，如果到全局作用域中也找不到就会报错 函数中要访问全局变量要使用window函数 在函数作用域中也有声明提前的特性 函数声明也会在函数所有代码执行之前执行 定义形参就相当于在函数作用域中声明了变量 123456789101112131415161718192021var a = 10;function fun()&#123; var a = \"我是fun函数中的a\" console.log(a);//输出 我是fun函数中的a var b = 20; function fun2()&#123; console.log(a);//输出 我是fun函数中的a console.log(window.a)//输出 10 &#125;&#125;console.log(b);fun();//输出10fun();fun();var e = 23;function fun6(e)&#123;//相当于在函数中var e alert(e);&#125;fun();//输出undefined","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"this","slug":"this","date":"2020-05-20T08:07:55.000Z","updated":"2020-05-30T10:01:05.294Z","comments":true,"path":"2020/05/20/this/","link":"","permalink":"https://xingkai520.github.io/2020/05/20/this/","excerpt":"解析器在调用函数每次都会向函数内部传递一个隐含的参数 这个隐含的参数就是this，this指向的是一个对象 这个对象我们称为函数执行的上下文对象 根据函数的调用方式的不同，this会指向不同的对象 ​ 1.以函数的形式调用时，this永远都是window ​ 2.以方法的形式调用时，this就是调用方法的那个对象 ​ 3.当以构造函数的形式调用时，this就是新创建的那个对象","text":"解析器在调用函数每次都会向函数内部传递一个隐含的参数 这个隐含的参数就是this，this指向的是一个对象 这个对象我们称为函数执行的上下文对象 根据函数的调用方式的不同，this会指向不同的对象 ​ 1.以函数的形式调用时，this永远都是window ​ 2.以方法的形式调用时，this就是调用方法的那个对象 ​ 3.当以构造函数的形式调用时，this就是新创建的那个对象 12345678910111213var name = \"全局\";function fun()&#123; console.log(this.name);//this.name表示谁调用就用谁里面的元素（谁调指谁）&#125;var obj = &#123; name:\"孙悟空\", sayName:fun &#125;var obj2 = &#123; name:\"沙和尚\", sayName:fun&#125;obj2.sayName();//输出沙和尚","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"js中的函数","slug":"js函数","date":"2020-05-14T06:10:09.000Z","updated":"2020-05-29T08:32:54.926Z","comments":true,"path":"2020/05/14/js函数/","link":"","permalink":"https://xingkai520.github.io/2020/05/14/js%E5%87%BD%E6%95%B0/","excerpt":"函数 函数也是一个对象 函数中可以装一些功能（代码），在需要时可以执行这些功能（代码）","text":"函数 函数也是一个对象 函数中可以装一些功能（代码），在需要时可以执行这些功能（代码） 创建函数对象12var fun = new Function();console.log(typeof fun);//返回function 可以将要封装的代码以字符串的形式传递给构造函数； 12var fun = new Function(\"console.log('这是一个函数');\");console.log(fun);//返回警告 封装到函数中的代码不会立即执行，函数中的代码会在函数调用时执行 在开发中很少用构造函数来创建一个函数对象 使用函数声明来创建一个函数 语法： ​ function 函数名（[形参1，形参2，….形参n]）{ ​ 函数体； ​ } 123456function fun2()&#123; console.log(\"这是第二个函数\"); alert(\"哈哈哈哈哈\"); document.write(\"啦啦啦啦\");&#125;fun2()//按顺序执行这三行代码 使用函数表达式来创建一个函数 语法 var 函数名 = function([形参1，形参2，…….形参n]){ ​ 语句…..； ​ } 1234var fun3 = function()&#123; console.log(\"我是匿名函数中的代码\");&#125;fun3();//执行函数中代码 构造函数可以创建一个构造函数专门用来创建person对象的，构造函数就是一个普通的含数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写 构造函数和普通函数的区别就是调用方式的不同 普通函数是直接调用，而构造函数需要使用new关键字来使用 构造函数的执行流程 1.立刻创建一个新的对象 2.将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建对象 3.逐行执行函数中的代码 4.将新建的对象作为返回值返回 使用同一个同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 123456function Person()&#123; this.name\"孙悟空\"&#125;var per = new Person();console.log(per)//输出不在是Object&#123;孙悟空&#125;而是person&#123;孙悟空&#125;console.log(per instanceof person);//使用instanceof可以检查一个对象是否是一个类的实例，是true，否false，所有的对象都是Object的后代，所以检查是否是Object类时全是true 123456789101112131415function Person(name , age , gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sayName = function () &#123; alert(this.name) &#125;&#125;var per2 = new Person(\"猪八戒\" , 28 , \"男\");var per3 = new Person(\"沙和尚\" , 28 , \"男\");var per4 = new Person(\"唐僧\" , 38 , \"男\");obj2.sayName();obj4.sayName();console.log(per2.sayName == per4.sayName);//输出false说明这两个sayName方法是独立创建的 在person构造函数中，为每一个对象都添加了一个sayName的方法 目前我们的方法是在构建函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法 也就是所有实例的sayName都是唯一的 这样就导致了构建函数执行一次就会创建一个新方法，执行100000次就会创建100000个新方法，而100000个方法都是一模一样的，这是完全没有必要的，完全可以使所有的对象共享用一个方法 将sayName方法在全局作用域中定义 12345678910111213141516function Person(name , age , gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sayName = fun;&#125;function fun()&#123; alert(this.name);&#125;var per2 = new Person(\"猪八戒\" , 28 , \"男\");var per3 = new Person(\"沙和尚\" , 28 , \"男\");var per4 = new Person(\"唐僧\" , 38 , \"男\");per2.sayName();per4.sayName();console.log(per2.sayName == per4.sayName);//输出true，说明这两个sayName方法是共用的 将函数定义在全局作用域中会占用全局作用域的命名空间，而且定义在全局作用域中也很不安全。尽量不要在全局作用域中定义函数 调用函数语法： 函数对象（） 当调用函数时，函数中封装的代码会按照顺序执行 函数对象含有普通对象的一切功能（添加、删除、修改…..） 12var fun = new Function(\"console.log('这是一个函数');\");fun();//返回 这是一个函数 call()和apply() 这两种方法都是函数对象的方法，需要通过对象来调用 当对函数调用call()和apply()都会调用函数执行 在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this call()方法可以将实参在对象之后依次传递 apply()方法需要将实参封装到一个数组里统一传递 this：1、以函数形式调用时，this永远都是window 2、以方法形式调用时，this时调用方法的对象 ​ 3、以构造函数的形式调用时，this是创建的那个对象 4、使用call和apply调用时，this是我们制定的 ​ 那个对象 12345678function fun()&#123; alert(this);&#125;var obj = &#123;&#125;;fun.call(obj);fun.apply(obj,[2,3]);fun.call(obj,2,3) 函数的参数定义一个用来求两个数的和的函数 可以在函数的（）中来指定一个或多个形参（形式参数） 多个形参之间用，隔开，声明形参就相当于在函数内部声明了对应的变量,但是并没有赋值 1234function sum(a,b)&#123; console.log(a+b);&#125;sum(1,2);//实参将会赋值给函数中对应的形参（a=1,b=2）,返回值是3 在调用函数时可以在（）中指定实参 实参将会赋值给函数中对应的形参 调用函数时解析器不会检查实参的类型 所以要注意，是否有可能会接受到非法的参数，如果有可能则需要对参数进行类型的检查 函数的实参可以是任意的数据类型 12345function sum(a,b)&#123; console.log(a+b);&#125;sum(123,\"hello\");//返回值为\"123hello\"sun(true,false);//返回值为1 调用函数时，解析器也不会检查实参的数量 多余的实参不会被赋值 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined 12345function sum(a,b)&#123; console.log(a+b);&#125;sum(123,456,\"hello\",true,false);//仍返回的是579sum(123);//输出NaN 函数的返回值可以使用return来设置函数返回值 语法：return 值; return后的值将会作为函数的执行结果返回，可以定义一个变量来接收该结果 变量result的值就是函数的执行结果，函数返回什么result的值就是什么 在函数中return后的语句都不会执行 如果return语句后不跟任何值，就相当于返回一个undefined 如果函数中不写return，则会返回undefined return后可以跟任意数据类型的值 123456function sum(a , b ，c)&#123; var d = a + b + c; return d;&#125;var result = sum(4,7,8);//将return的值赋给了resultconsole.log(result);//输出19 只要使用了return就会结束整个函数，不论return有多深，函数中return后的函数都不执行 实参可以是任何值 实参可以是任意的数据类型，也可以是一个对象 当我们的参数过多时，可以将参数封装到一个对象，然后通过对象传递 12345678910function xinxi(o)&#123; console.log(\"我是\"+o.name+\"，我今年\"+o.age+\"岁，我是\"+o.gender+\"人，家住在\"+o.address);&#125;var obj = &#123; name:\"孙悟空\", age:\"18\", gender:\"男\", address:\"花果山\"&#125;xinxi(obj);//输出 我是孙悟空，我今年18岁，我是男人，家住在花果山 函数就是一个对象，所以也可以作为参数 12345678910111213function xinxi(o)&#123; console.log(\"我是\"+o.name+\"，我今年\"+o.age+\"岁，我是\"+o.gender+\"人，家住在\"+o.address);&#125;var obj = &#123; name:\"孙悟空\", age:\"18\", gender:\"男\", address:\"花果山\"&#125;function fun(a)&#123; a(obj);&#125;fun(xinxi);//输出仍然是 我是孙悟空，我今年18岁，我是男人，家住在花果山 立即执行函数函数定义完，立即被调用，这种函数叫做立即执行函数， 立即执行函数往往只会执行一次 12345678(function()&#123; alert(\"我是一个匿名函数\");&#125;)();(function(a,b)&#123; console.log(a); console.log(b);&#125;)(123,456);//输出123456","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"js中的对象","slug":"js中的对象","date":"2020-05-12T13:32:31.000Z","updated":"2020-06-05T14:27:37.913Z","comments":true,"path":"2020/05/12/js中的对象/","link":"","permalink":"https://xingkai520.github.io/2020/05/12/js%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"js中的对象除了五种基本数据类型外还有一个引用数据类型：Object 对象(以后我们看到的值，只要不是五种基本数据类型的，全都是对象)","text":"js中的对象除了五种基本数据类型外还有一个引用数据类型：Object 对象(以后我们看到的值，只要不是五种基本数据类型的，全都是对象) 如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体，例如： 123var name = \"孙悟空\";var gender = \"男\";var age = \"18\";//这三个数据毫无关联，互相独立 Js中的变量都是保存到栈内存中的 基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响到其他变量 对象是保存在堆内存中，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个对象通过一个变量修改属性时，另一个也会受影响 当给其中一个对象赋值时，会切断与之前地址的连接 当比较两个两个基本数据类型时，就是比较的值，而比较两个引用数据类型时，是比较对象的内存地址，如果两个对象的值是一模一样的，但地址不同，也会返回false 对象属于一种复合的数据类型，在对象中可以保存多个不同类型的属性 对象的分类 1.内建对象 由ES标准中定义的对象，在仍何的ES实现中都可以使用，如：Math String Number Boolean…… 2.宿主对象 由JS的运行环境提供的对象，目前主要是指由浏览器提供的对象，如：BOM DOM 3.自定义对象 由开发人员自己创建的对象 ps:对象就像一个塑料袋！！ 内建对象数组（Array） 数组也是一个对象 他和我们普通的对象功能相似，也是用来存储一些值的 不同的是普通对象是使用字符串作为属性名的，而数组是使用数字作为索引来操作对象 索引： 从零开始的整数就是索引 数组的存储性能比普通对象要好，在开发中我们经常使用数组来储存一些数据 创建数组对象 语法：数组[索引] = 值 12345var arr = new Array();console.log(arr);//输出\"\" 空的，因为里面没有元素arr[0] = 10;arr[1] = 33;console.log(arr);//输出10,33 使用字面量创建数组 语法：[] 使用字面量创建数组时，可以在创建时就指定数组中的元素 使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数参数传递，元素之间用，隔开 当只传一个数时，字面量传的是一个元素而构造函数传的是数组的元素数量 123456789var arr = new Array();var arr = [];console.log(arr);//返回值为空（没有设置元素）var arr = [1,2,3,4,10];console.log(arr[4]);//返回值为10 var arr2 = new Array(10,20,30);console.log(arr2);//返回值为10,220,30（与上面的方法效果一样） 引用数组对象 语法：数组[索引] 如果读取不存在的索引，不会报错而是返回undefined 1234var arr = new Array();arr[0] = 10;arr[1] = 33;console.log(arr[1]);//输出33 获取对象长度 可以使用length属性来获取数组的长度 对于连续的数组使用length可以获取到数组的长度（元素个数） 对于非连续的数组，使用length会获取到数组的最大索引+1 尽量不要创建非连续的数组，占空间 语法：数组.length 1234567var arr = new Array();arr[0] = 10;arr[1] = 33;console.log(arr.length);//输出2arr[10] = 50;console.log(arr.length);//输出11console.log(arr)//[ 10, 33, &lt;8 empty items(8个空的项目)&gt;, 50 ] 修改length 如果修改的length大于原长度，则多余部分会空出来 如果修改的length小于原长度，则多出部分会被删除 1234567891011var arr = new Array();arr[0] = 10;arr[1] = 11;arr[2] = 22;arr[3] = 33;arr.length = 10;console.log(arr.length);//输出10console.log(arr)//输出[ 10, 11, 22, 33, &lt;6 empty items&gt; ]arr.length = 2;console.log(arr.length);//输出2console.log(arr)//输出10,11 向最后的一个位置添加元素 12345678910var arr = new Array();arr[0] = 10;arr[1] = 11;arr[2] = 22;arr[3] = 33;console.log(arr.length);//输出4console.log(arr)//输出10,11,22,33arr[arr.length] = 44;console.log(arr.length);//输出5console.log(arr)//输出10,11,22,33,44 数组中的元素可以是任意的数据类型 123var arr = new Array();arr = [\"hello\",true,null,undefined];console.log(arr)//输出hello，1，true， ， 也可以是对象 123var obj = &#123;name:\"孙悟空\"&#125;;arr[arr.length] = obj;console.log(arr[5].name);//输出孙悟空 也可以是个函数 1234var arr = new Array();arr = [function()&#123;alert(1)&#125;,function()&#123;alert(2)&#125;];console.log(arr);//输出function()&#123;alert(1)&#125;,function()&#123;alert(2)&#125;arr[0]();//弹出1 数组中也可以放数组，如下这种数组叫二维数组 123var arr = new Array();arr = [[1,2,3],[4,5,6],[7,8,9]];console.log(arr[0]);//输出1，2,3 push（） 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度 可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾 该方法会将数组的新长度作为返回值返回 123456var arr = new Array();var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];arr.push(\"唐僧\");console.log(arr);//输出孙悟空，猪八戒，沙和尚，唐僧arr.push(\"蜘蛛精\",\"白骨精\");console.log(arr);//输出孙悟空，猪八戒，沙和尚，唐僧，蜘蛛精,白骨精 12345var arr = new Array();var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];var result = arr.push(\"蜘蛛精\",\"白骨精\",\"唐僧\");console.log(arr);//输出孙悟空，猪八戒，沙和尚，唐僧，蜘蛛精,白骨精console.log(result);//输出 6 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度。 像前面插入元素以后，其他元素会依次往后推 123456var arr = new Array();var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];var result = arr.push(\"蜘蛛精\",\"白骨精\",\"唐僧\");console.log(arr);arr.unshift(\"牛魔王\",\"二郎神\");console.log(arr);//输出 牛魔王,孙悟空，猪八戒，沙和尚，唐僧，蜘蛛精,白骨精 pop() shift() pop(); 删除数组最后一个元素，并返回元素的值 shift()；删除数组第一个元素，并返回元素的值 数组的遍历 一般是使用for循环来遍历数组 123456var arr = new Array();var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];var result = arr.push(\"蜘蛛精\",\"白骨精\",\"唐僧\");for(var i = 0 ; i &lt; arr.length ; i++)&#123; console.log(arr[i]);//输出孙悟空，猪八戒，沙和尚，唐僧，蜘蛛精,白骨精&#125; js中还提供了了一个方法，用来遍历数组 forEach() 这个方法只支持ie8以上的浏览器 forEach() 方法需要一个函数作为参数 像这种函数，由我们创建但是不由我们调用的，我们称为回调函数 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的行书传递进来 浏览器会在回调函数中传递三个参数 第一个参数：当前正在遍历的函数 第二个参数：当前正在遍历的元素的索引 第三个参数：正在遍历的数组 123456789101112var arr = new Array();var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\",\"蜘蛛精\",\"白骨精\",\"唐僧\"];arr.forEach(function fun(a , b , c)&#123; console.log(a);//输出 孙悟空 猪八戒 沙和尚 蜘蛛精 白骨精 唐僧 console.log(b);//输出 0 1 2 3 4 5 console.log(c);//输出[ '孙悟空', '猪八戒', '沙和尚', '蜘蛛精', '白骨精', '唐僧' ] //[ '孙悟空', '猪八戒', '沙和尚', '蜘蛛精', '白骨精', '唐僧' ] //[ '孙悟空', '猪八戒', '沙和尚', '蜘蛛精', '白骨精', '唐僧' ] //[ '孙悟空', '猪八戒', '沙和尚', '蜘蛛精', '白骨精', '唐僧' ] //[ '孙悟空', '猪八戒', '沙和尚', '蜘蛛精', '白骨精', '唐僧' ] //[ '孙悟空', '猪八戒', '沙和尚', '蜘蛛精', '白骨精', '唐僧' ]&#125;); slice() 可以用来从数组提取指定元素 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回 参数：slice(第一个参数，第二个参数) 第一个参数：截取开始的位置索引（必须写） 第二个参数：截取结束的位置索引（可省略，省略后会截取开始往后的所有元素） 索引可以传递一个负值，如果传递一个负值则从后往前计算-1倒数第一个-2倒数第二个 12345var arr = new Array();var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\",\"蜘蛛精\",\"白骨精\",\"唐僧\"];console.log(arr.slice(0,2));//输出'孙悟空', '猪八戒'console.log(arr.slice(2));//输出'沙和尚', '蜘蛛精', '白骨精', '唐僧'console.log(arr.slice(-2));//输出'白骨精', '唐僧' splice() 可以删除或修改、添加数组中的指定元素 使用splice会影响到原数组，会将指定元素从原数组中删除，并将被删元素作为返回值 参数 splice(第一个参数，第二个参数) 第一个参数（必写）： 开始删除的位置索引 第二个参数（必写）： 表示删除的数量 第三个及以后参数（可不写）：可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边 12345var arr = new Array();var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\",\"蜘蛛精\",\"白骨精\",\"唐僧\"];var result = arr.splice(2,2,\"白龙马\",\"红孩儿\",\"玉兔精\");console.log(arr);//输出'孙悟空', '猪八戒', '白龙马', '红孩儿','玉兔精', '白骨精', '唐僧' console.log(result);//输出'沙和尚', '蜘蛛精' concat（） 可以连接两个或多个数组，并将新的数组返回 该方法不会影响原函数 1234var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];var arr2 = [\"蜘蛛精\",\"白骨精\",\"唐僧\"];var result = arr.concat(arr2,\"牛魔王\");console.log(result);//输出 '孙悟空', '猪八戒', '沙和尚', '蜘蛛精', '白骨精', '唐僧' , '牛魔王' join() 该方法可以将数组转换为一个字符串 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 在join（）中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符 123var arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];console.log(arr.join());//输出孙悟空,猪八戒,沙和尚（默认用，连接数组内元素）console.log(arr.join(哈哈));//输出 孙悟空哈哈猪八戒哈哈沙和尚 reverse() 该方法用来反转数组（前边去后边，后边去前边） 该方法会改变原数组 sort() 可以对数组进行排序，默认会按照Unicode编码进行排序（因为是按照Unicode编码排序，所有可能会与自己的期望有很大出入） 会影响原数组 我们可以自己来指定排序顺序 我们可以在sort（）添加一个回调函数，来指定排序规则， 回调函数需要定义两个形参， 浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但肯定的是在数组中a一定在b前面 浏览器会根据回调函数的返回值来决定元素的顺序 如果返回一个大于0的值，则元素会交换位置 如果返回一个小于0的值，则元素位置不变 如果返回一个0，则认为两个元素相等，也不交换位置 如果需要升序排列，则返回a-b，降序排列，则返回b-a 12345678910var arr = [\"a\",\"e\",\"d\",\"c\",\"b\"];arr.sort();console.log(arr);//输出'a', 'b', 'c', 'd', 'e'var arr = [1,2,7,9,2,9,4,9,4,6,1,51,55,1,5,161,51,881,8,4];arr.sort(function fun(a,b)&#123; return a-b;&#125;);console.log(arr);//输出[1, 1, 1, 2, 2, 4, 4, 4, 5, 6, 7, 8, 9, 9, 9, 51, 51, 55, 161, 881] 自定义对象 创建对象 1、使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数 12var obj = new Object();console.log(typeof obj);//返回Object 在对象中保存的值称为属性，向对象中添加属性 语法：对象.属性名 = 属性值; 1234var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性 2、使用对象字面量来创建一个对象（使用对象字面量可以在创建对象时，直接指定对象中的属性） 对象字面量的属性名可以加引号也可以不加引号，建议不加。 如果要使用一些特殊的名字则必须加引号“！@￥#@……” 语法：{属性名：属性值，属性名：属性值，…..} 1234567891011var obj = &#123;&#125;;console.log(typeof obj);//输出objectobj.name = \"孙悟空\";console.log(obj.name);//输出孙悟空var obj2 = &#123; name:\"猪八戒\", age:28, gender:\"男\" &#125;;console.log(obj2);//输出 猪八戒 28 男 3、使用工厂方法创建对象 通过该方法可以大批量的创造对象 使用工厂方法创建的对象使用的构造函数都是Object，所以创建的对象都是Object这个类型，就导致我们无法区分出多个不同类型的对象 12345678910111213141516function createPerson(name , age , gender) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function () &#123; alert(this.name) &#125; return obj;&#125;var obj2 = createPerson(\"猪八戒\" , 28 , \"男\");var obj3 = createPerson(\"沙和尚\" , 28 , \"男\");var obj4 = createPerson(\"唐僧\" , 38 , \"男\");console.log(obj2);//输出猪八戒obj4.sayName();//输出唐僧 构造函数 可以创建一个构造函数专门用来创建person对象的，构造函数就是一个普通的含数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写 构造函数和普通函数的区别就是调用方式的不同 普通函数是直接调用，而构造函数需要使用new关键字来使用 构造函数的执行流程 1.立刻创建一个新的对象 2.将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建对象 3.逐行执行函数中的代码 4.将新建的对象作为返回值返回 使用同一个同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 123456function Person()&#123; this.name\"孙悟空\"&#125;var per = new Person();console.log(per)//输出不在是Object&#123;孙悟空&#125;而是person&#123;孙悟空&#125;console.log(per instanceof person);//使用instanceof可以检查一个对象是否是一个类的实例，是true，否false，所有的对象都是Object的后代，所以检查是否是Object类时全是true 读取对象中的属性 语法：对象.属性名 如果读取对象中没有的属性不会报错，会返回undefined 123456var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性console.log(obj.name);//输出孙悟空console.log(obj.hello);//输出undefined 修改对象的属性值 语法：对象.属性名 = 新值 123456var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性obj.name = \"齐天大圣\";console.log(obj.name);//输出齐天大圣 删除对象的属性 语法：delete 对象.属性名 123456var obj = new Object();obj.name = \"孙悟空\";//添加一个name属性obj.gender = \"男\";//添加一个gender属性obj.age = 18;//添加一个age属性delete obj.name;console.log(obj.name);//输出undefined 属性名和属性值 属性名： 对象的属性名不强制要求遵守标识符的规范,什么名字都可以使用，但是使用时尽量按照标识符的规范去做 如果要使用特殊的属性名（如123等数字），不能采用.的方式来操作，需要使用另一种方式 语法：对象[“属性名”] = 属性值 1234567891011var obj = new Object();obj.var = \"hello\";//添加一个var属性console.log(obj.var);//输出helloobj.123 = 789;//报错obj[\"123\"] = 789;console.log(obj[\"123\"]);//输出789obj[\"！#￥%……&amp;#&amp;*&amp;%*&amp;\"] = \"这就是我\";console.log(obj[\"！#￥%……&amp;#&amp;*&amp;%*&amp;\"]);//输出 这就是我；尽量别这样 使用[]这种形式去操作属性，更加的灵活。 在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性 1234567var obj = new Object();obj[\"123\"] = 789;obj[\"nihao\"] = \"你好\";var n = \"123\";console.log(obj[n]);//输出789n = \"nihao\";console.log(obj[n]);//输出 你好 属性值 JS对象的属性值可以是任意的数据类型 1234567891011var obj = new Object();obj.test = \"hello\";console.log(obj.test);//输出helloobj.test = 123;console.log(obj.test);//输出123obj.test = true;console.log(obj.test);//输出trueobj.test = null;console.log(obj.test);//输出nullobj.test = undefined;console.log(obj.test);//输出undefined 甚至也可以是一个对象（套娃）、函数 如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法 调用函数就说调用对象的方法(method) 但是它只是名称上的区别没有其他的区别 1234567891011121314151617181920212223242526var obj = new Object();var obj2 = new Object();obj2.name = \"猪八戒\";obj.test = obj2;console.log(obj);//输出&#123; test: &#123; name: '猪八戒' &#125; &#125; console.log(obj.test);//输出&#123; name: '猪八戒' &#125;console.log(obj.test.name);//输出“猪八戒”var obj = Object();obj.name = \"孙悟空\";obj.age = \"18\";obj.sayName = function()&#123; console.log(obj.name);&#125;;obj.sayName();//输出孙悟空obj.sayName = function()&#123; console.log(obj.name);&#125;;function fun()&#123; console.log(obj.name);&#125;;obj.sayName();//调方法 //只是名称的区分，本质是一样的fun();//调函数 in运算符 通过该运算符可以检查一个对象中是否含有指定的属性 如果有则返回true，没有则返回false 语法： “属性名” in 对象 检查obj中是否含有test2的属性: 12345678910var obj = new Object();var obj2 = new Object();obj2.name = \"猪八戒\";obj.test = obj2;console.log(obj);//输出&#123; test: &#123; name: '猪八戒' &#125; &#125; console.log(obj.test);//输出&#123; name: '猪八戒' &#125;console.log(obj.test.name);//输出“猪八戒”console.log(\"test2\" in obj);//obj没有test2的属性 输出falseconsole.log(\"test\" in obj);//obj有test的属性 输出trueconsole.log(\"name\" in obj);//obj有name的属性 输出true 枚举对象中的属性枚举对象中的属性 使用for…in语句 for…in语句 对象中有几个属性，循环体就会执行几次 每次执行时会将对象中一个属性的名字赋值给变量 123456789101112131415//语法for(var 变量 in 对象)&#123;&#125;var obj = &#123; name:\"孙悟空\", age:18, gender:\"男\" address:\"花果山\" &#125;;for(var n in obj)&#123; console.log(\"hello\");//输出四次hello，因为obj对象中只有三个属性 console.log(n);//输出name age gender address console.log(obj[n]);//输出孙悟空 18 男 花果山&#125; 原型prototype我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 如果函数作为普通函数调用prototype没有任何作用 当函数以构造函数的形式调用时，他所创建的对象中都会有一个隐含得属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 当我们访问对象的一个属性或方法时，他会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果有会直接使用 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，作用不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了 1234567891011121314151617function MyClass()&#123; &#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;MyClass.prototype.sayName = function()&#123; alert(\"hello\")&#125;var mc = new MyClass();var mc2 = new MyClass();console.log(mc.__proto__ == MyClass.prototype);//输出trueconsole.log(mc.a);//输出123mc.a = \"我是mc中的a\";console.log(mc.a);//输出我是mc中的aconsole.log(mc2.a);//输出123mc.sayName();//输出hellomc2.sayName();//输出hello 使用in检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回true 1234567function MyClass()&#123; &#125;MyClass.prototype.name = \"我是原型中的名字\";var mc = new MyClass();mc.age = 18;console.log(mc.name);//返回true 可以使用对象的hasOwnProperty()来检查对象自身是否含有属性，自身中含有该属性时返回true 12345MyClass.prototype.name = \"我是原型中的名字\";var mc = new MyClass();mc.age = 18;console.log(mc.hasOwnProperty(\"age\"));//输出trueconsole.log(mc.hasOwnProperty(\"name\"));//输出false 原型对象也是对象，所以它也有原型， 当我们使用一个对象的属性或方法时，会在自身中寻找， 自身如果有，则直接使用， 如果没有则会去原型对象中寻找，如果原型对象中有则使用 如果没有则去原型的原型中寻找，直到找到Object对象的原型， Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined 12console.log(mc.__proto__.hasOwnProperty(\"hasOwnProperty\"));//输出falseconsole.log(mc.__proto__.__proto__.hasOwnProperty(\"hasOwnProperty\"));//输出true,说明hasOwnProperty在原型的原型中","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"git基础","slug":"git基础","date":"2020-05-09T02:08:52.000Z","updated":"2020-05-09T02:54:58.188Z","comments":true,"path":"2020/05/09/git基础/","link":"","permalink":"https://xingkai520.github.io/2020/05/09/git%E5%9F%BA%E7%A1%80/","excerpt":"git是什么？ git是一个非常优秀的版本控制系统，两个作用： 1）版本控制 2）协作开发 协作开发也是基于版本控制 git是用来管理你写的代码的。","text":"git是什么？ git是一个非常优秀的版本控制系统，两个作用： 1）版本控制 2）协作开发 协作开发也是基于版本控制 git是用来管理你写的代码的。 之前写代码模式： 创建一个文件夹 在这个文件夹下开始写代码 之前写代码的模式缺点： 1）没有版本 开发一个项目 v1 v2 v3 v4 2）不好管理 不好维护 团队协作开发时 -————————————git历史？ 大家自己百度一下 -————————————现在版本控制系统有哪些？ 1）svn 集中式版本控制系统 2）git 分布式版本控制系统 -————————————集中式版本控制系统？ 代表就是SVN 有点out了 就不讲了 只有一个远程的代码仓库，所有的程序员都维护这一个代码仓库。 不足： 1）如果远程仓库挂了，所有的版本都没有了 2）svn推送或拉取最新版本是基于文件传输的，速度比较慢一点 3）所有的版本都存储在远程仓库，每个程序员手头只有最新的版本，没有历史版本，进行版本管理时，不太好管理 -————————————分布式版本控制系统？ 代表就是git 现在用的非常多 在公司中每天都会用到 每一个程序员电脑上都有一个仓库，叫它为本地仓库。 优点： 1）如果远程仓库挂了，程序员手头还有所有的版本，数据不会丢失 2）是基于文件流进行传输的，速度快一点 3）所有程序员手头都所有的版本，代码管理起非常方便 -————————————github 和 git 有什么区别？ 1）git是一个管理代码的工具 2）github是一个网站 可以充当一个远程仓库 这个网址是程序员的聚集地 -————————————安装git这个工具： 直接百度搜索git 找到官网 下载这个工具 安装是傻瓜式安装 一路下一步 下一步就OK了 在使用git bash here时，你在哪个文件夹下点击了，它会自动定位到这个文件夹 -————————————安装完后，还需要告诉git你是谁？ 答：就是配置用户名和邮箱 最好是你先去注册一个github账号 注册完github账号后，你就有用户名和邮箱了 git config –global user.name “wangcai” git config –global user.email “1234567890@qq.com“ 设置用户名和邮箱只需要做一次就OK了。 -————————————常用的linux命令： ls 罗列出当前文件夹下面都有哪些文件或目录 mkdir css 表示在当前目录下面创建一个css文件夹 touch index.html 表示创建一个index.html文件 cd css 表示进入到css文件夹中 可以按tab键自动补全 cd .. 表示回到上一级目录 pwd 查看当前处理哪个目录下面（得到全路径） clear 清屏 rm index.html 表示删除一个文件 rmdir css 表示删除一个空的文件夹 ….. -————————————本地仓库： 一个空的文件夹，并不是一个本地仓库。 如何得到一个本地仓库呢？ 答：通过一个命令就可以得到本地仓库，叫git init 如果在一个文件夹（xxx）中通过git init命令创建出来了一个.git隐藏文件夹，那么这个文件夹(xxx)就是一个本地仓库了。 -————————————一个本地仓库是由几块区域组成： 1）工作区(.git之外的区域) 2）.git .git里面又包含两块区域 一块叫暂存区 一块叫历史区 .git文件夹，任何时候都不要动 写代码都在工作区进行写代码。 -————————————工作区： 就是程序员写代码的区域 只在工作区写代码 并不能形成版本 只有把代码扔到历史区，才能形成版本，但是你还不能直接把工作区的代码扔到历史区，你需要先把代码扔到暂存区，然后再从暂存区扔到历史区，形成版本。 -————————————查看历史区都有哪些版本？ 答：git log -————————————git常用命令： 1）git init 初始化一个本地仓库 2）git add * 把工作区的代码扔到暂存区 3）git commit -m ‘xx’ 把暂存区的代码扔到历史区形成一个版本 4）git log 查看历史区都有哪些版本 -————————————查看文件状态： git status 红色：代表当前工作区的文件并没有扔到暂存区 绿色：代表没有把暂存区的文件扔到历史区 -————————————回滚： 回到之前的版本 git reset –hard HEAD^ 表示回到上一个版本 HEAD^^表示回到上上一个版本 -————————————查看带有回滚的历史区版本的信息： 之前git log，只能查看当前历史区的版本，不带回滚的信息 现在git reflog，可看带有回滚版本的信息 -————————————总结： 1）git init 初始化本地仓库 2）配置用户名和邮箱 git config –global user.name “wangcai” git config –global user.email “1234567890@qq.com“ 3）git add 4）git commit -m “xx” 5）git log / git reflog 6）git reset –hard HEAD^/id 后悔药 7）git status 红色 绿色 什么分布式 什么是集中式-————————————","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://xingkai520.github.io/tags/git/"}]},{"title":"js中一些常用的语句","slug":"js中一些常用的语句","date":"2020-04-29T10:01:00.000Z","updated":"2020-06-01T08:41:14.303Z","comments":true,"path":"2020/04/29/js中一些常用的语句/","link":"","permalink":"https://xingkai520.github.io/2020/04/29/js%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5/","excerpt":"一些常用的Js语句","text":"一些常用的Js语句 prompt() prompt()可以弹出一个提示框，该提示框会带有一个文本框，用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数，该字符串会作为提示框的提示文字 用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容 函数的返回值为string函数 1var a = prompt(\"请输入小明的成绩：\"); document.write(); document.write()，可以向网页中输出一段文字 拼接字符串，用加号”+”，字符串用双引号””括起来。 1234567document.write(1);//在网页中输出1var a = 123;document.write(a);//网页中输出123var a = \"双胞胎哥哥\";document.write(a + \"双胞胎弟弟\");//输出:双胞胎哥哥双胞胎弟弟 console.time(); console.time(“计时器的名字”)可以开启一个计时器 他需要一个字符串作为参数，这个字符串将会作为计时器的标识 console.timeEnd(“计时器的名字”)用来停止一个计时器，需要一个计时器的名字作为参数 123456789101112131415console.time(\"test\");var num , a , b , c;for(num = 2 ; num &lt;= 100 ; num ++)&#123; c = 0; for(a = num ; a &gt; 1 ; a --)&#123; b = num % a; if(b == 0)&#123; c++; &#125; &#125; if(c == 1)&#123; document.write(num + \"&lt;br&gt;\"); &#125;&#125;console.timeEnd(\"test\"); Math.sqrt() Math和其他对象不同，他不是一个构造函数，他属于一个工具类不用创建对象，它里边封装了数学运算的相关的属性和方法 Math.sqrt对一个数字进行开方 Math.PI圆周率 Math.ceil可以对一个数进行向上取整，小数位只要有值就自动进1 Math.floor可以对一个数进行向上下整，小数部分会被省略 Math.round可以对一个数进行四舍五入取整 Math.random可以生成一个0-1之间的随机数 Math.pow（x，y）返回x的y次幂 ……还有很多用的时候可以找 1Math.sqrt(36);//返回值为6 Date()对象 在js中使用Date对象来表示一个时间 如果直接使用构造函数创建一个Date对象，则会封装成为当前代码执行的时间 12var d = new Date();console.log(d);//输出2020-05-30T10:07:35.592Z 创建一个指定的时间对象 需要在构造函数中传递一个表示时间的字符串作为参数 12var d2 = new Date(\"05/30/2020 11:10:30\");console.log(d2);//输出2020-05-30T03:10:30.000Z（慢8个小时） getDate()获取当前日期对象是几日 getDay()获取当前日期的对象是周几（0-6） getMonth()获取当前日期对象是几月（0一月—-11十二月） getFullYear()获取当前日期对象是几年 …….还有很多 123456789var d2 = new Date(\"05/30/2020 11:10:30\");var date = d2.getDate();var day = d2.getday();var month = d2.getMonth();var year = d2.getFullYear();console.log(date);//输出30console.log(day);//输出6console.log(month);//输出4console.log(year);//输出2020 get time（）：获取当前对象的时间戳 时间戳，指的是从格林威治标准时间的1970年1月1日0时0分0秒，到这个代码表示的时间所花费的毫秒数 计算机底层在保存时间时使用的都是时间戳","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"流程控制语句","slug":"流程控制语句","date":"2020-04-29T09:01:00.000Z","updated":"2020-05-12T06:36:59.855Z","comments":true,"path":"2020/04/29/流程控制语句/","link":"","permalink":"https://xingkai520.github.io/2020/04/29/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","excerpt":"流程控制语句 Js中的程序是从上到下一行行执行的 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行 语句的分类： 1、条件判断语句 2、条件分支语句 3、循环语句","text":"流程控制语句 Js中的程序是从上到下一行行执行的 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行 语句的分类： 1、条件判断语句 2、条件分支语句 3、循环语句 条件判断语句使条件判断语句可以在执行某个语句之前进行判断，如果条件成立才会执行语句，条件不成立则语句不执行。 if语句 语法一： ​ if(条件表达式) { ​ 语句….. ​ } if语句在执行时会先对条件表达式进行求值判断，如果条件表达式的值为true，则执行if后的语句。如果条件表达式的值为false则不会执行if后的语句 if语句只能控制紧随其后的语句，如果希望if语句控制多个语句可以将这些语句统一放到代码块里面 if后的一条语句时不需要加代码块，但是在开发中尽量写上代码块，即使if后面只有一条语句，结构更清楚 1234567891011121314151617181920212223242526272829if(true) alert(\"你猜我出来吗？\");//执行弹出文字if(false) alert(\"你猜我出来吗？\");//不执行var a = 10;if(a &gt; 10) alert(\"a比10大\");//不执行var a = 11;if(a &gt; 10) alert(\"a比10大\");//执行var a = 10;if(a &gt; 10) alert(\"a比10大\");//不执行 alert(\"管不到我！\");//执行var a = 10;if(a &gt; 10)&#123; alert(\"a比10大\");//不执行 alert(\"管不到我！\");//不执行&#125;var a = 15;if(a &gt; 10 &amp;&amp; a&lt;= 20) alert(\"a比10大且a小于20\");//不执行 语法二： ​ if(条件表达式) { ​ 语句….. ​ }else{ ​ 语句…… ​ } 当该语句执行时会对if后的条件表达式进行求值判断，如果为true则执行if后的语句，如果值为false则执行else后的语句 123456var a = 50;if(a&gt;60)&#123; console.log(\"你已经退休了\");&#125;else&#123; console.log(\"你还没退休\");&#125; 语法三： 123456if(条件表达式) &#123; 语句...... &#125;else if(条件表达式)&#123; 语句...... &#125;else if(条件表达式)&#123; 语句...... &#125;else 当该语句执行时会从上到下依次对条件表达式进行求值判断，如果值为true则执行当前语句，如果值为false则继续向下，如果条件都不满足则执行最后的else语句 该语句中只会有一个代码块被执行，一但代码块被执行了，则直接结束语句 1234567891011121314var a = 50;if(a &gt; 100)&#123; console.log(\"活着挺没意思\");&#125;else if(a &gt; 80)&#123; console.log(\"你也老大不小了\");&#125;else if(a &gt; 60)&#123; console.log(\"你该退休了\")&#125;else if(a &gt; 40)&#123; console.log(\"你已经中年了\")&#125;else if(a &gt; 18)&#123; console.log(\"你已经成年了\")&#125;else&#123; console.log(\"你还是个小孩\")&#125; 条件分支语句条件分支语句也叫作switch语句 switch语句语法 1234567891011121314switch(条件表达式)&#123; case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; &#125; 执行流程： switch…case…语句在执行时依次将case后的表达式的值和switch后的条件表达式的值进行全等比较 如果比较结果为true，则从当前case处开始执行代码，当前case后的所有代码都会执行，所以语句后面需要break;这样可以确保只执行当前case后的语句，而不会执行其他的case 如果比较结果为false，则继续向下比较。 如果所有的比较结果都为false则执行default后面的语句 12345678910111213141516171819202122232425var a = 1;switch(a)&#123; case 1: console.log(\"壹\") break; case 2: console.log(\"贰\") break; case 3: console.log(\"叁\") break; default: console.log(\"非法数字\") break;&#125;var a = 1;switch(true)&#123; case a &gt;= 60: console.log(\"及格\") break; default: console.log(\"不合格\") break;&#125; 循环语句通过循环语句可以反复执行一段代码多次 while循环 语法： 123while(条件表达式)&#123; 语句...; &#125; while语句在执行时，先对条件表达式进行求值判断，如果值是true，则执行循环体，循环体执行完毕后，继续对表达式进行判断，如果为true则继续执行循环体，循环此操作……..直到条件表达式判断为false则停止循环 1234var n = 1;while(true)&#123; alert(n++);&#125;//不停的弹出自增的数字；这样的叫做死循环，该循环不会停止除非关闭浏览器，开发慎用 可以用break跳出循环 1234567var n = 1;while(true)&#123; alert(n++); if(n&gt;10)&#123; break;//跳出循环 &#125;&#125; 创建一个循环，往往需要三个步骤 1234567891011//1、初始化一个变量var i = 0;//2、在循环中设置一个条件表达式while(i &lt; 10)&#123; alert(1);&#125;//3、定义一个更新表达式，每次更新初始化变量while(i &lt; 10)&#123; alert(i); i++;&#125; do…while循环 语法： 123do&#123; 语句...；&#125;while(条件表达式) 执行流程： do…while语句在执行时，会先执行循环体，循环体执行完以后，在对while后面的条件表达式进行判断，如果结果为true则继续执行循环体，如果结果为false则终止循环 实际上这两个语句相似，不同的是while是先判断再执行，do…while是先执行再判断（do…while可以保证循环体至少执行一次） for循环在for循环中，为我们提供了专门的位置来放三个表达式： 1、初始化表达式 2、条件表达式 3、更新表达式 语法： 1234567for(初始化表达式;条件表达式;更新表达式)&#123; 语句... &#125; for(var i = 0 ; i &lt; 10 ; i++)&#123; alert(i);&#125; 执行流程 1.执行初始化表达式，初始化变量。（初始化表达式只能执行一次） 2.执行条件表达式，判断是否执行循环，如果为true则执行循环，如果为false则终止循环。 3.执行更新表达式，更新表达式执行完毕继续重复第二步 for循环中的三个部分都可以省略，也可以写在外部 123456789var i = 0;for(;i&lt;10;)&#123; alert(i++);&#125;//循环输出10次for(;;)&#123; \"hello\"&#125;//死循环输出hello 终止break break关键字可以用来退出switch或循环语句(不能在裸if语句中使用) break关键字会立即终止离他最近的那个循环语句 123456789101112for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); break;&#125;for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); if(i&gt;5)&#123; break;//此时break作用于外部的for &#125;&#125; 可以为外循环创建一个label，来标识当前的循环 label:循环语句 使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的 12345678outer:for(var i=0 ; i&lt;10 ; i++)&#123; document.write(@i); for(var j=0 ; j&lt;10 ; j++)&#123; document.write(i); break outer;//直接结束外部循环 &#125; &#125; continue continue关键字可以跳过当次循环 continue只能用于循环语句 同样continue也是默认对离他最近的循环起作用 123456for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); if(i == 5)&#123; continue;//输出了除了5的小于10的正整数（跳过了i=5的本次循环） &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"上传博客图片无法显示问题","slug":"上传博客图片无法显示问题","date":"2020-04-23T09:25:29.000Z","updated":"2020-04-23T09:36:00.231Z","comments":true,"path":"2020/04/23/上传博客图片无法显示问题/","link":"","permalink":"https://xingkai520.github.io/2020/04/23/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/","excerpt":"上传博客无法引用本地图片问题","text":"上传博客无法引用本地图片问题 ## 1.下载插件 首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 123npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save或npm install hexo-asset-image --save 2.要将要引入的图片放入与md文件同名的文件夹中在下载插件完成之后再git bush中输入hexo n “text”可生成一个新的md文件和同名文件夹，将你要引入的图片放入这个文件夹内引用 3.在引入图片时不能使用Markdown语法引入不能使用 1![](img&#x2F;img.png) 应使用 1&#123;% asset_img 图片.jpg 图片描述 %&#125; 例如： 使用 1![](img&#x2F;img.png) 可以在本地看到图片但上传至hexo中看不到图片,使用 1&#123;% asset_img 图片.jpg 图片描述 %&#125; 能让你上传至hexo的文章中看到图片但在本地看不到。 我是为了本地观察方便也将写入其中，但不影响上传","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://xingkai520.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"viewport","slug":"viewport","date":"2020-04-23T08:26:09.000Z","updated":"2020-04-23T09:36:39.197Z","comments":true,"path":"2020/04/23/viewport/","link":"","permalink":"https://xingkai520.github.io/2020/04/23/viewport/","excerpt":"viewport的属性","text":"viewport的属性 1width=device-width 视口的宽度 通常设置成device-width(设备自身的宽度) 1initial-scale=1 设置页面的初始缩放值 1maxinum-scale=1.0 允许用户的最大缩放值 是一个数字 可以是小数 1mininum-scale=1.0 允许用户的最小缩放值 是一个数字 可以是小数 1user-scalable=no user-scalable : 用户是否可以手动缩放，值可以是：①yes、 true允许用户缩放；②no、false不允许用户缩放 1viewport-fit: cover; 应对留海屏幕的填充问题 (1) inital-scale也是用来设置视口的，前面说了，width是用来设置视口，其实有这样一个公式，如下： 视口 = 设备独立像素宽度 / inital-scale 可以通过inital-scale间接地设置视口，操作如下： 现在不让inital-scle是1，设置成2，如下： 那假如我把inital-scale=0.5，效果如下： 此时，我们设置视口，就有两种方式，如下： 12width=device-wdithinital-scale = 1 如果有一个人，它设置了width=device-wdith，又设置了inital-scale = 1，以谁为主。如果说你这样设置了，不放大，也不缩小，如下： 如果这样设置，如下： 则以最大的为主：","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Javascript基础","slug":"javascript基础","date":"2020-04-22T12:28:30.000Z","updated":"2020-07-07T06:56:28.681Z","comments":true,"path":"2020/04/22/javascript基础/","link":"","permalink":"https://xingkai520.github.io/2020/04/22/javascript%E5%9F%BA%E7%A1%80/","excerpt":"Javascript基础","text":"Javascript基础 ### **基本知识：** 控制浏览器弹出一个警告框 1alert(\"帅帅帅\") 让浏览器在界面中输出一个内容(向body中输出一个内容) 1document.write(\"你好！！！\") 向控制台输出一个内容 1console.log(\"控制台你好！！！\") 可以将js代码写到标签的onclick属性中。不方便维护，不推荐使用。 1&lt;button onclick=\"alert('点我干嘛--');\"&gt;点我点我&lt;/button&gt; 可以将js代码写在超链接的href属性中，这样当点击超链接时会执行js代码（前面必须加上JavaScript：） 1&lt;a href=\"javascript:alert('让你点你就点-_-!');\"&gt;也点我点我&lt;/a&gt; 一般是写在js文件中用以下代码连接 1&lt;script type=\"text/javascript\" src=\"./js/index.js\"&gt;&lt;/script&gt; 一但这个script标签用于引入外部js文件，那么这个script标签再编写代码将被浏览器忽略 如果需要则需要再写一个script标签 执行顺序从上到下执行 字面量 都是一些不可改变的量 比如：1 2 3 4 5。字面量都是可以直接使用的，如下 1alert(2132146489); 字面量都是可以直接使用，但是我们一般都不会直接使用字面量 变量变量可以用来保存字面量，而且变量的值是可以任意改变的 变量更加方便使用，所以在开发中都是通过变量去保存一个字面量 很少直接使用字面量 声明变量：在js中使用var关键字来声明一个变量 1var a; 需要给变量赋值 1a = 123; 可以声明和赋值同时进行 1var b = 846815; 变量声明提前 使用var关键字声明的变量，会在所有的代码执行之前被声明(但是不会赋值) 但是声明变量时不使用var关键字，则变量不会被声明提前 函数的声明提前 使用函数声明形式创建的函数function函数(){} 他会在所有的代码执行之前就被创建，所以这种方式写的函数可以在函数声明前来调用 使用函数表达式创建的函数，不会被声明提前 1234567891011121314151617a = 123;console.log(a);//输出 a = 123;console.log(a);//输出 a=undefined 没有报错var a = 123;console.log(a);//报错a = 123;fun();//输出我是一个fun函数fun2();//报错function fun()&#123; console.log(\"我是一个fun函数\");&#125;var fun2 = function()&#123; console.log(\"我是fun2函数\");&#125; 标识符在js中所有的可以由我们自主命名的都可以称为是标识符 例如：变量名、函数名、属性名都属于标识符 命名一个标识符时需要遵守如下的规则： 1.标识服中可以含有字母、数字、_、$ 2.标识符不能以数字开头 3.标识符不能是ES中的关键字或保留字 4.标识符一般采用驼峰命名法（首字母小写，每个开头字母大写，其余字母小写。不强制要求，但是是个好习惯） 5.JS底层保存标识符时实际上是采用Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符 6.var只在声明变量时使用，在后续需要修改时不需要再重复给一个变量var 12345678var a_1$ = 3;var var = 3；//不能这样helloWorld xxxYyyZzz//驼峰命名法var 我最帅 = 384;//可以用，但是不推荐这样用，不符合行业规范var str1 = 1;str1 = 2;//最后命名的变量值有效 数据类型数据类型指的就是字面量的类型 在JS中一共有六种数据类型： String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中String Number boolean Null Undefined属于基本数据类型，而Object属于引用数据类型 用法 String 字符串 在Js中字符串需要使用引号引起来 单引号和双引号都可以用没区别，但是不要混着用 不要在双引号中放双引号 可以在单引号中用双引号 在字符串中我们可以使用\\作为转义字符，当表示一些特殊符号时可以使用\\转义 1234567891011var str = \"hello\";console.log(str);var str = 'hello\"; //不要混着用var str = \"我说：\"今天天气真不错！\"\";//这样不对，会把”我说：“看做一个变量var str = '我说：\"今天天气真不错！\"';//这样可以var str = \"我说：\\\"今天天气真不错！\\\"\";//这样也可以，让里面的双引号仅仅代表双引号\\' 表示 ’\\\" 表示 \"\\n 表示换行\\t 制表符 \\\\ 表示\\ 我转义我自己 Number 数值 在JS中所有数值都是Number类型，包括整数和浮点数（小数） 数字123和字符123完全不同 可以使用一个typeof来检查一个变量类型 typeof+变量 JS中可以表示数字的最大值：Number.MAX_VALUE 可以用Number.MAX_VALUE*Number.MAX_VALUE，取最大值的平方 如果超过了最大值则会输出Infinity，表示正无穷；-Infinity表示负无穷 用两个字符串相乘：abc*bcd会输出NaN；NaN是一个特殊的数字，表示Not a number（不是数字） 使用typeof检查NaN会返回number Number.MIN_VALUE的值为0以上的最小值0.000000….. 在Js中整数的运算基本可以保证精确 如果使用JS进行浮点元素的计算，可能的到一个不精确的解果；因为二进制无法精确1/10; 可以把后面的数字给省略掉，但前提是不能涉及到钱，所以不要用JS计算精确度要求比较高的运算 1234567891011121314var a = 123;//数字123var b = \"123\";//字符123console.log(typeof a)//检查字符串时，会返回string；检查数值时，会返回numberconsole.log(Number.MAX_VALUE);a = Number.MAX_VALUE*Number.MAX_VALUE;//会输出Infinity，a = \"abc\"*\"bcd\"//输出NaNconsole.log(typeof a)//会输出numbera = Number.MIN_VALUEconsole.log(a)//输出5e-324var c = 1234456 + 4894894;//输出结果正确var c = 0.1 + 0.2;//输出结果为0.30000000000000000004 Boolean 布尔值 布尔值只有两个：true、false；真、假。主要用来做逻辑判断 true：表示真 false：表示假 使用typeof检查会输出boolean 123var bool = ture;console.log(bool);//输出为trueconsole.log(typeof bool)//输出为boolean Null类型的值只有一个，就是Null null（空值）专门用来表示为空的对象 使用typeof检查null会返回Object Undefined（未定义）类型的值只有一个，就是Undefined 当声明一个变量，但是不给变量赋值时，他的值就是Undefined 12345var a = null;console.log(a);//输出就是nullconsole.log(typeof a);//输出是Objectvar b = undefined;console.log(typeof b);//输出是undefined 其他进制数字 在js中如果需要表示16进制的数字，则需要以0x开头 如果要表示8进制的数字，则需要以0开头 如果要表示2进制的数字，则需要以0b开头，但是不是所有的浏览器都支持 输出的时候会转换为10进制输出 1234567//16进制var a = 0x10;console.log(a);//输出为16//8进制var a = 070;console.log(a);//输出为56 强制类型转换 指讲一个数据类型强制转换为其他的数据类型 类型转换主要指，将其他的数据类型，转换为：String、Number、Boolean 将其他的数据类型转换为String 方式一 调用被转换数据类型的toString()方法 该方法不会影响到原变量，会将转换的结果返回 但是要注意Null和Undefined这两个值没有toString方法，如果用这个方法调用会报错 方式二 调用String()函数，并将被转换的数据作为参数传递给函数 String（）函数做强制类型转换时对于Number和Boolean实际上就是调用toString()方法 但对于Null和Undefined，就不会和toString（）一样，他会将Null和Undefined直接转换为字符串“Null”和“Undefined” 将其他数据类型转换为Number 没有toNumber方式 方式一 使用Number()函数 1.如果是纯数字的字符串，则将其转换为数字 2.如果字符串中有非数字的内容，则转换为NaN 3.如果字符串为空串或者是一个全空格的字符串，则转换为数字0 4.true转换成数字1，false转换成数字0，Null转换成数字0，Undefined转换为NaN 方式二 这种方式专门用来对付字符串 parseInt（）把一个字符串转换为一个整数 可以将一个字符串中有效的整数内容取出来然后转换为Number，只读到从左到右第一个不为数字的地方 parseFloat（）把一个字符串转换为一个浮点数（小数） 可以将一个字符串的有效的小数取出，如果有两个小数点，则读到第二个小数点前 如果对String使用parseFloat（）、parseInt（），他会将其先转换为string，然后再操作 将其他数据类型转换为Boolean类型 方式 使用Boolean（）函数 数字转Boolean，除了0和NaN其余的都是true 字符串转Boolean，除了空串其余的都是true Null与Undefined转换为Boolean，都是false 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//将其他的数据类型转换为String//方式一：var a = 123;console.log(typeof a);//输出为Numberconsole.log(a);//输出为123a.toString();//调用a的toString()方法console.log(typeof a);//输出仍为Numbervar b = a.toString();console.log(typeof b);//输出为Stringconsole.log(b);//输出为123a = a.toString();//可以赋值给自己console.log(typeof a);//输出为Stringconsole.log(a);//输出为123a = true;a = toString();console.log(typeof a);//输出为Stringconsole.log(a);//输出为truea = Null;a = toString();//报错a = Undefined;a = toString();//报错//方式二：var a = 123;String(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123a = 123;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为123a = Null;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为Nulla = Undefined;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为Undefined//将其他数据类型转换为Number：//方式1：var a = \"123\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"abc\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = true;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为1var a = false;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = Null;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = Undefined;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaN//方式二：parseInt();var a = \"123px\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"123px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"123a564px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"a123px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"123.456px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = 123.456;parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123,可以用来取整//parseFloat();var a = \"123.456px\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123.456var a = \"123.456.789px\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123.456var a = \"true\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaN//转换其他进制时//转换8进制，这种字符串，有些浏览器（IE）会当成8进制解析，有些浏览器会当成10进制解析var a = 070;a = parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为56（或70）//可以在parseInt（）中传递第二个参数，来制定数字的进制var a = 070;a = parseInt(a,10);//把070当做10进制看console.log(typeof a);//输出为Numberconsole.log(a);//输出为70var a = 070;a = parseInt(a,8);//把070当做8进制看console.log(typeof a);//输出为Numberconsole.log(a);//输出为56//将其他数据类型转换为Boolean类型//数字转换为Boolean：var a = 123;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为truevar a = 0;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为falsea = -123;//truea = Infinity;//truea = NaN;//falsea = \"true\"//字符串转换为Boolean：var a = \"\";a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为false//Null与Undefined转换为Boolean：var a = Null;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为falsevar a = Undefined;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为false 运算符 运算符也叫作操作符 通过运算符可以对一个或多个值进行运算 比如：typeof就是运算符，可以用来获得一个值的类型，他会将该值的类型以字符串的形式返回 1234var a = 123;var result = typeof a;console.log(result);//输出numberconsole.log(typeof result);//输出string 算数运算符 +可以对两个值进行加法运算，并将值返回，如果对字符串进行加法操作则会对两个字符串做拼接处理，任何值和字符串做加法运算都是要将其转换成字符串然后再拼串处理；可以利用这一特点可以将任意类型的数据加一空串””就可以将这个数据类型变为字符串类型 -可以对两个值进行减法运算，并将值返回 *可以对两个值进行乘法运算，并将值返回 /可以对两个值进行除法运算，并将值返回 %取模运算（取余数） 对于非Number类型的值进行运算时，会将这些值转换成Number然后运算(除了加法)，可以通过给一个值-0，*1，/1,都可以转换为number类型 任何值和NaN做运算都得NaN 123456789101112131415161718192021222324252627282930313233343536var a = 1;var result;result = a + 1;//输出2result = true + 1;//输出2result = true + false;//输出1result = null + 1;//输出1result = NaN + 1;//输出NaNresult = \"123\" + \"456\";//输出123456；string类型result = \"你好\" + \"帅哥\";//输出你好帅哥；string类型var str = \"锄禾日当午，\" + //双引号必须在一行 \"汗滴禾下土。\" + \"谁知盘中餐，\" + \"粒粒皆辛苦。\";console.log(str);//输出锄禾日当午，汗滴禾下土。谁知盘中餐，粒粒皆辛苦。var c = 123;c = c + \"\";console.log(typeof c);//输出为stringconsole.log(c);//输出为123//减法：var result;result = 100 - \"1\";//输出99result = 2 * \"8\";//输出16var c = 123;c = c - 0;console.log(typeof c);//输出为numberconsole.log(c);//输出为123//取模：var a = 9 % 3;console.log(a);//输出为0var a = 9 % 4;console.log(a);//输出为1 一元运算符 一元运算符只需要一个操作数 +：正号 正号不会对数字产生任何影响，可以将其他类型转换为number类型 -：负号 负号可以对数字进行数字取反,对于非number值，先转换成number再进行取反 123456789101112131415161718192021222324252627var a = 123;a = +a;console.log(a);//输出为123var a = 123;a = -a;console.log(a);//输出为-123var a = true;a = -a;console.log(a);//输出为-1console.log(typeof a);//输出为numbervar a = \"123\";a = +a;console.log(a);//输出为123console.log(typeof a);//输出为numbervar a;a = 1 + \"2\" + 3;console.log(a);//输出为123console.log(typeof a);//输出为stringvar a;a = 1 + +\"2\" + 3;console.log(a);//输出为6console.log(typeof a);//输出为number 自增自减 自增：++ 通过自增可以使变量在自身的基础上增加1 对一个变量自增后，原变量会立即加1 自增分为两种:后++（a++）和前++（++a） 无论是a++还是++a都立即使原变量的值自增1 不同的是a++和++a的值不同 a++的值等于原变量的值（自增前的值） ++a的值等于原变量自增后的值 自减：”–” 通过自减可以使变量在自身的基础上减1 对一个变量自减后，原变量会立即减1 自减分为两种:后”–”（a”–”）和前”–”（”–”a） 无论是a”–”还是”–”a都立即使原变量的值自减1 不同的是a”–”和”–”a的值不同 a”–”的值等于原变量的值（自减前的值） “–”a的值等于原变量自减后的值 1234567891011121314151617181920212223242526272829//自增：var a = 1;a++;console.log(a);//输出为2var a = 1;console.log(a++);//输出为1console.log(a);//输出为2var a = 1;++a;console.log(a);//输出为2var a = 1;console.log(++a);//输出为2console.log(a);//输出为2var a = 20;a = a++ + ++a +a;//20+22+22console.log(a);//输出为2//自减：与自加一样var b = 10;b--;console.log(b);//输出为9var b = 10;--b;console.log(a);//输出为9 逻辑运算符js中为我们提供了3种逻辑运算符 &amp;&amp;与 可以对符号两侧的值进行与运算，并返回结果 两个值中只要有一个值为false就返回false，两个都是true才能返回true JS中的“与“属于短路的与，如果第一个值为false就不再看后面的值 ||或 可以对符号两侧的值进行或运算，并返回结果 只要有一个true就返回true JS中的“或“属于短路的或，如果第一个值为true就不再看后面的值 ！非 可以对一个值进行非运算 就是对一个布尔值进行取反操作 如果对一个非布尔值进行运算，则会将其转换为布尔值然后取反 可以利用这个特点将其他类型转换为布尔值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//&amp;&amp;与var result = true &amp;&amp; true;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = false &amp;&amp; false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; alert(\"你看我出不出来！！\");//运行弹出\"你看我出不出来！！\"var result = false &amp;&amp; alert(\"你看我出不出来！！\");//运行没有弹出\"你看我出不出来！！\"//||或var result = false || false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = true || false;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true || true;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; alert(\"你看我出不出来！！\");//运行没有弹出\"你看我出不出来！！\"var result = false &amp;&amp; alert(\"你看我出不出来！！\");//运行弹出\"你看我出不出来！！\"//!非var a = true;a = !a;console.log(a);//输出为falsevar a = true;a = !!a;console.log(a);//输出为truevar a = 10;a = !a;console.log(a);//输出为falseconsole.log(typeof a);//输出为Booleanvar a = 10;a = !!a;console.log(a);//输出为trueconsole.log(typeof a);//输出为Boolean 对于非布尔值进行与或运算时，会将其转换为布尔值，然后再运算，并且返回原值 与运算：如果第一个值为true，则直接返回第二个值，如果第一个值为false，则直接返回第一个值（找false） 或运算：如果第一个值为true，则直接返回第一个值，如果第一个值为false，则直接返回第二个值（找true） 12345678910111213141516171819202122232425262728293031323334//与：var a = 1 &amp;&amp; 2;console.log(a);//输出为2var a = 2 &amp;&amp; 1;console.log(a);//输出为1var a = 0 &amp;&amp; 1;console.log(a);//输出为0var a = 1 &amp;&amp; 0;console.log(a);//输出为0var a = NaN &amp;&amp; 0;console.log(a);//输出为NaNvar a = 0 &amp;&amp; NaN;console.log(a);//输出为NaN//或：var a = 2 || 1;console.log(a);//输出为2var a = 1 || 0;console.log(a);//输出为1var a = 1 || NaN;console.log(a);//输出为1var a = NaN || 1;console.log(a);//输出为1var a = NaN || 0;console.log(a);//输出为1 赋值运算符 =：可以将符号右侧的值赋值给符号左侧的变量 +=:a = a + 5等价于a = a + 5（+=不能分开写成+ =） -=:a = a - 5等价于a = a - 5（-=不能分开写成- =） =:a = a * 5等价于a = a * 5（=不能分开写成 * =） /=:a = a / 5等价于a = a / 5（/=不能分开写成/ =） %=:a = a % 5等价于a = a % 5（%=不能分开写成% =） 1234567891011121314151617181920212223242526var a = 123;console.log(a);//输出为123var a = 10;a = a + 5;console.log(a);//输出为15var a = 10;a += 5;console.log(a);//输出为15var a = 10;a -= 5;console.log(a);//输出为5var a = 10;a *= 5;console.log(a);//输出为50var a = 10;a /= 5;console.log(a);//输出为2var a = 10;a %= 5;console.log(a);//输出为0 关系运算符 通过关系运算符可以比较两个值之间的关系，如果关系成立则返回true，不成立则返回false “&gt;”判断左侧关系是否大于右侧，若大于则立即返回true，如果关系不成立则返回false “&gt;=”判断左侧关系是否大于或等于右侧，若大于或等于则立即返回true，如果关系不成立则返回false “==”判断左右是否相等，相等返回true，不相等返回false，NaN不和任何值比较包括他本身，可以用函数isNaN()来判断一个值是否是NaN “===”全等 和相等类似，但是他不会做自动转换，如果两个值类型不同直接返回false “！==”不全等 和不等类似，但是他不会做自动转换，如果两个值类型不同直接返回true “!=”判断左右是否相等，不相等返回true，相等返回false “&lt;=”判断左侧关系是否小于或等于右侧，若小于或等于则立即返回true，如果关系不成立则返回false “&lt;”判断左侧关系是否小于右侧，若小于则立即返回true，如果关系不成立则返回false 对于非数值类型判断，则先将其转化为数值类型再判断 任何数和NaN比都是false 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较，而是比较的Unicode编码，一位一位的对位比较，所以可以借用这个方法对英文进行排序，比较中文没有意义，对于两个字符串的数字比较一定要转型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var a = 5 &gt; 10;console.log(a);//输出为falsevar a = 5 &gt; 4;console.log(a);//输出为truevar a = 5 &gt; 5;console.log(a);//输出为falsevar a = 5 &gt;= 5;console.log(a);//输出为truevar a = 1 &gt; true;console.log(a);//输出为falsevar a = 1 &gt;= true;console.log(a);//输出为falsevar a = 1 &gt; \"0\";console.log(a);//输出为truevar a = 1 &gt; NaN;console.log(a);//输出为false，任何数和NaN比都是falsevar a = true &gt; false;console.log(a);//输出为truevar a = \"5\" &lt; \"11\";console.log(a);//输出为truevar a = \"11\" &lt; \"5\";console.log(a);//输出还是truevar a = \"11\" &lt; +\"5\";console.log(a);//输出还是falsevar a = \"a\" &lt; \"b\";console.log(a);//输出是truevar a = \"b\" &lt; \"a\";console.log(a);//输出是falsevar a = \"abc\" &lt; \"b\";console.log(a);//输出是true，一位一位进行比较var a = \"bbc\" &lt; \"b\";console.log(a);//输出是false，一位一位进行比较var a = \"b\" &lt; \"a\";console.log(a);//输出是falsevar a = NaN == NaN;console.log(a);//输出是falsevar a = NaN;console.log(isNaN(a));//输出是true 条件运算符 条件运算符又叫三元运算符：”条件表达式?语句1:语句2” 条件运算符在执行时，首先对条件表达式进行求值 如果该值为true则执行语句1，并返回执行结果0 如果该值为false则执行语句2，并返回执行结果 如果条件表达式的求值结果是一个非布尔值，会将其转化为布尔值，然后再运算 1234567891011121314151617181920212223242526272829303132true?alert(\"语句1\"):alert(\"语句2\");//执行语句1false?alert(\"语句1\"):alert(\"语句2\");//执行语句2var a = 10;var b = 20;a &gt; b ? alert(\"a大\"):alert(\"b大\");//b大//获取a和b中的最大值var a = 10;var b = 20;var max = a &gt; b ? a : b; console.log(max)//输出b//获取a和b、c中的最大值var a = 10;var b = 20;var c = 50;var max = a &gt; b ? a : b; max = max &gt;c ? max : c;console.log(max)//输出cvar a = 10;var b = 20;var c = 50;var max = a &gt; b ? a &gt; c ? a : c : b &gt; c ? b : c; //a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c); 不推荐使用，不方便阅读console.log(max)//输出50\"hello\"?alert(\"语句1\"):alert(\"语句2\");//执行语句1\"\"?alert(\"语句1\"):alert(\"语句2\");//执行语句2 运算符的优先级 , 运算符：使用，可以分割多个语句，一般可以在声明多个变量时使用（用的最多） 12var a , b , c;var a = 1 , b = 2 , c = 3; 和数学中一样，JS中运算符也有优先级 先乘除后加减 12var result = 1 + 2 * 3;console.log(result)//输出7 &amp;&amp;的优先级比||高 在Js中有一个运算优先级的表，在表中越靠上优先级越高，优先级高的优先计算，如果优先级一样高，则从左到右计算，这个表不需要硬记，如果遇到优先级不清楚的，用（）分开 12var result = 1 || 2 &amp;&amp; 3;console.log(result)//输出1 Unicode编码在字符串中使用转义字符输入unicode编码，\\u+四位编码 12console.log(\"\\u0031\");//输出1console.log(\"\\u2620\");//输出☠（骷髅头） 要在网页中使用Unicode编码 123&lt;h1&gt; &amp;#编码&lt;!--这里的编码需要的是10进制--&gt;&lt;/h1&gt; 代码块（语句） 我们的程序就是由一条条语句构成的 执行的时候从上到下执行 用{}为语句分组 同一个{}我们称为一组语句，要么都执行要么都不执行。也叫作代码块，在}=后不用加； Js中的代码块只有分组的作用没有其他的作用 1elert(\"hello\");//这就是语句 注意 js中严格区分达小写 js中每一条语句以分号结尾（如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，有些时候浏览器会加错分号，所以在开发中必须加分号） js会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 注释多行注释/**/ 单行注释//","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://xingkai520.github.io/tags/Javascript/"}]},{"title":"移动端视口适配","slug":"视口移动端适配","date":"2020-04-16T11:13:58.000Z","updated":"2020-04-23T09:36:28.950Z","comments":true,"path":"2020/04/16/视口移动端适配/","link":"","permalink":"https://xingkai520.github.io/2020/04/16/%E8%A7%86%E5%8F%A3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","excerpt":"移动端视口适配","text":"移动端视口适配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@media screen and (min-width:320px) &#123; html &#123; font-size: 21.33px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:360px) &#123; html &#123; font-size: 24px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:375px) &#123; html &#123; font-size: 25px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:384px) &#123; html &#123; font-size: 25.6px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:400px) &#123; html &#123; font-size: 26.67px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:414px) &#123; html &#123; font-size: 27.6px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:424px) &#123; html &#123; font-size: 28.27px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:480px) &#123; html &#123; font-size: 32px &#125; body &#123; font-size: 15.36px &#125;&#125;@media screen and (min-width:540px) &#123; html &#123; font-size: 36px &#125; body &#123; font-size: 17.28px &#125;&#125;@media screen and (min-width:720px) &#123; html &#123; font-size: 48px &#125; body &#123; font-size: 23.04px &#125;&#125;@media screen and (min-width:750px) &#123; html &#123; font-size: 50px &#125; body &#123; font-size: 24px &#125;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"写博客基础","slug":"我的第一个博客","date":"2020-04-05T12:40:00.000Z","updated":"2020-05-09T01:26:28.964Z","comments":true,"path":"2020/04/05/我的第一个博客/","link":"","permalink":"https://xingkai520.github.io/2020/04/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","excerpt":"Markdown的一些基本语法","text":"Markdown的一些基本语法 **1）标题** 一级标题二级标题三级标题四级标题五级标题六级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 ==2）字体== 加粗 倾斜 ==高亮== 删除线 我是^上标^ 我是下标 1234567891011**加粗***倾斜*&#x3D;&#x3D;高亮&#x3D;&#x3D;~~删除线~~我是^上标^我是~下标~ ==3）列表== 第一级实心圆（按tab换级） 第二级空心圆 第三级实心方框 第四级及之后都是实心方框 按回车取消本级 有序列表 英文状态下的1. 按回车自动添加表头数字 再按回车取消本行 1234567891011+ 第一级实心圆（按tab换级） + 第二级空心圆 + 第三级实心方框 + 第四级及之后都是实心方框按回车取消本级1. 有序列表2. 英文状态下的1.3. 按回车自动添加表头数字4. 再按回车取消本行 ==4）表格== mon tue wed thu 哈哈 哈哈哈 哈哈哈哈 哈哈哈哈哈 啦啦 啦啦啦 啦啦啦啦 啦啦啦啦啦 1234| mon | tue | wed | thu || ---- | ------ | -------- | ---------- || 哈哈 | 哈哈哈 | 哈哈哈哈 | 哈哈哈哈哈 || 啦啦 | 啦啦啦 | 啦啦啦啦 | 啦啦啦啦啦 | ==5）引用== 一级引用 再加&gt;变为二级引用 以此类推 按回车取消一级 1234567&gt; 一级引用&gt;&gt; &gt;再加&gt;变为二级引用&gt; &gt;&gt; &gt;&gt; 以此类推&gt; &gt;&gt;&gt; &gt;&gt; &gt; 按回车取消一级 ==6）分割线== 1-------- ==7）代码== 代码块 12代码块​```+语言 代码 12&#96;代码&#96;","categories":[],"tags":[{"name":"Markdown常用语法","slug":"Markdown常用语法","permalink":"https://xingkai520.github.io/tags/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://xingkai520.github.io/tags/html/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"https://xingkai520.github.io/tags/css/"},{"name":"git","slug":"git","permalink":"https://xingkai520.github.io/tags/git/"},{"name":"博客","slug":"博客","permalink":"https://xingkai520.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://xingkai520.github.io/tags/Javascript/"},{"name":"Markdown常用语法","slug":"Markdown常用语法","permalink":"https://xingkai520.github.io/tags/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}]}