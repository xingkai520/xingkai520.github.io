{"meta":{"title":"Hexo","subtitle":"","description":"","author":"xingkai","url":"https://xingkai520.github.io","root":"/"},"pages":[],"posts":[{"title":"git基础","slug":"git基础","date":"2020-05-09T02:08:52.000Z","updated":"2020-05-09T02:54:58.188Z","comments":true,"path":"2020/05/09/git基础/","link":"","permalink":"https://xingkai520.github.io/2020/05/09/git%E5%9F%BA%E7%A1%80/","excerpt":"git是什么？ git是一个非常优秀的版本控制系统，两个作用： 1）版本控制 2）协作开发 协作开发也是基于版本控制 git是用来管理你写的代码的。","text":"git是什么？ git是一个非常优秀的版本控制系统，两个作用： 1）版本控制 2）协作开发 协作开发也是基于版本控制 git是用来管理你写的代码的。 之前写代码模式： 创建一个文件夹 在这个文件夹下开始写代码 之前写代码的模式缺点： 1）没有版本 开发一个项目 v1 v2 v3 v4 2）不好管理 不好维护 团队协作开发时 -————————————git历史？ 大家自己百度一下 -————————————现在版本控制系统有哪些？ 1）svn 集中式版本控制系统 2）git 分布式版本控制系统 -————————————集中式版本控制系统？ 代表就是SVN 有点out了 就不讲了 只有一个远程的代码仓库，所有的程序员都维护这一个代码仓库。 不足： 1）如果远程仓库挂了，所有的版本都没有了 2）svn推送或拉取最新版本是基于文件传输的，速度比较慢一点 3）所有的版本都存储在远程仓库，每个程序员手头只有最新的版本，没有历史版本，进行版本管理时，不太好管理 -————————————分布式版本控制系统？ 代表就是git 现在用的非常多 在公司中每天都会用到 每一个程序员电脑上都有一个仓库，叫它为本地仓库。 优点： 1）如果远程仓库挂了，程序员手头还有所有的版本，数据不会丢失 2）是基于文件流进行传输的，速度快一点 3）所有程序员手头都所有的版本，代码管理起非常方便 -————————————github 和 git 有什么区别？ 1）git是一个管理代码的工具 2）github是一个网站 可以充当一个远程仓库 这个网址是程序员的聚集地 -————————————安装git这个工具： 直接百度搜索git 找到官网 下载这个工具 安装是傻瓜式安装 一路下一步 下一步就OK了 在使用git bash here时，你在哪个文件夹下点击了，它会自动定位到这个文件夹 -————————————安装完后，还需要告诉git你是谁？ 答：就是配置用户名和邮箱 最好是你先去注册一个github账号 注册完github账号后，你就有用户名和邮箱了 git config –global user.name “wangcai” git config –global user.email “1234567890@qq.com“ 设置用户名和邮箱只需要做一次就OK了。 -————————————常用的linux命令： ls 罗列出当前文件夹下面都有哪些文件或目录 mkdir css 表示在当前目录下面创建一个css文件夹 touch index.html 表示创建一个index.html文件 cd css 表示进入到css文件夹中 可以按tab键自动补全 cd .. 表示回到上一级目录 pwd 查看当前处理哪个目录下面（得到全路径） clear 清屏 rm index.html 表示删除一个文件 rmdir css 表示删除一个空的文件夹 ….. -————————————本地仓库： 一个空的文件夹，并不是一个本地仓库。 如何得到一个本地仓库呢？ 答：通过一个命令就可以得到本地仓库，叫git init 如果在一个文件夹（xxx）中通过git init命令创建出来了一个.git隐藏文件夹，那么这个文件夹(xxx)就是一个本地仓库了。 -————————————一个本地仓库是由几块区域组成： 1）工作区(.git之外的区域) 2）.git .git里面又包含两块区域 一块叫暂存区 一块叫历史区 .git文件夹，任何时候都不要动 写代码都在工作区进行写代码。 -————————————工作区： 就是程序员写代码的区域 只在工作区写代码 并不能形成版本 只有把代码扔到历史区，才能形成版本，但是你还不能直接把工作区的代码扔到历史区，你需要先把代码扔到暂存区，然后再从暂存区扔到历史区，形成版本。 -————————————查看历史区都有哪些版本？ 答：git log -————————————git常用命令： 1）git init 初始化一个本地仓库 2）git add * 把工作区的代码扔到暂存区 3）git commit -m ‘xx’ 把暂存区的代码扔到历史区形成一个版本 4）git log 查看历史区都有哪些版本 -————————————查看文件状态： git status 红色：代表当前工作区的文件并没有扔到暂存区 绿色：代表没有把暂存区的文件扔到历史区 -————————————回滚： 回到之前的版本 git reset –hard HEAD^ 表示回到上一个版本 HEAD^^表示回到上上一个版本 -————————————查看带有回滚的历史区版本的信息： 之前git log，只能查看当前历史区的版本，不带回滚的信息 现在git reflog，可看带有回滚版本的信息 -————————————总结： 1）git init 初始化本地仓库 2）配置用户名和邮箱 git config –global user.name “wangcai” git config –global user.email “1234567890@qq.com“ 3）git add 4）git commit -m “xx” 5）git log / git reflog 6）git reset –hard HEAD^/id 后悔药 7）git status 红色 绿色 什么分布式 什么是集中式-————————————","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://xingkai520.github.io/tags/git/"}]},{"title":"js中一些常用的语句","slug":"js中一些常用的语句","date":"2020-04-29T10:01:00.000Z","updated":"2020-05-12T10:06:59.846Z","comments":true,"path":"2020/04/29/js中一些常用的语句/","link":"","permalink":"https://xingkai520.github.io/2020/04/29/js%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5/","excerpt":"一些常用的Js语句","text":"一些常用的Js语句 prompt() prompt()可以弹出一个提示框，该提示框会带有一个文本框，用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数，该字符串会作为提示框的提示文字 用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容 函数的返回值为string函数 1var a = prompt(\"请输入小明的成绩：\"); document.write(); document.write()，可以向网页中输出一段文字 拼接字符串，用加号”+”，字符串用双引号””括起来。 1234567document.write(1);//在网页中输出1var a = 123;document.write(a);//网页中输出123var a = \"双胞胎哥哥\";document.write(a + \"双胞胎弟弟\");//输出:双胞胎哥哥双胞胎弟弟 console.time(); console.time(“计时器的名字”)可以开启一个计时器 他需要一个字符串作为参数，这个字符串将会作为计时器的标识 console.timeEnd(“计时器的名字”)用来停止一个计时器，需要一个计时器的名字作为参数 123456789101112131415console.time(\"test\");var num , a , b , c;for(num = 2 ; num &lt;= 100 ; num ++)&#123; c = 0; for(a = num ; a &gt; 1 ; a --)&#123; b = num % a; if(b == 0)&#123; c++; &#125; &#125; if(c == 1)&#123; document.write(num + \"&lt;br&gt;\"); &#125;&#125;console.timeEnd(\"test\"); Math.sqrt()可以通过Math.sqrt对一个数字进行开方","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"流程控制语句","slug":"流程控制语句","date":"2020-04-29T09:01:00.000Z","updated":"2020-05-12T06:36:59.855Z","comments":true,"path":"2020/04/29/流程控制语句/","link":"","permalink":"https://xingkai520.github.io/2020/04/29/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","excerpt":"流程控制语句 Js中的程序是从上到下一行行执行的 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行 语句的分类： 1、条件判断语句 2、条件分支语句 3、循环语句","text":"流程控制语句 Js中的程序是从上到下一行行执行的 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行 语句的分类： 1、条件判断语句 2、条件分支语句 3、循环语句 条件判断语句使条件判断语句可以在执行某个语句之前进行判断，如果条件成立才会执行语句，条件不成立则语句不执行。 if语句 语法一： ​ if(条件表达式) { ​ 语句….. ​ } if语句在执行时会先对条件表达式进行求值判断，如果条件表达式的值为true，则执行if后的语句。如果条件表达式的值为false则不会执行if后的语句 if语句只能控制紧随其后的语句，如果希望if语句控制多个语句可以将这些语句统一放到代码块里面 if后的一条语句时不需要加代码块，但是在开发中尽量写上代码块，即使if后面只有一条语句，结构更清楚 1234567891011121314151617181920212223242526272829if(true) alert(\"你猜我出来吗？\");//执行弹出文字if(false) alert(\"你猜我出来吗？\");//不执行var a = 10;if(a &gt; 10) alert(\"a比10大\");//不执行var a = 11;if(a &gt; 10) alert(\"a比10大\");//执行var a = 10;if(a &gt; 10) alert(\"a比10大\");//不执行 alert(\"管不到我！\");//执行var a = 10;if(a &gt; 10)&#123; alert(\"a比10大\");//不执行 alert(\"管不到我！\");//不执行&#125;var a = 15;if(a &gt; 10 &amp;&amp; a&lt;= 20) alert(\"a比10大且a小于20\");//不执行 语法二： ​ if(条件表达式) { ​ 语句….. ​ }else{ ​ 语句…… ​ } 当该语句执行时会对if后的条件表达式进行求值判断，如果为true则执行if后的语句，如果值为false则执行else后的语句 123456var a = 50;if(a&gt;60)&#123; console.log(\"你已经退休了\");&#125;else&#123; console.log(\"你还没退休\");&#125; 语法三： 123456if(条件表达式) &#123; 语句...... &#125;else if(条件表达式)&#123; 语句...... &#125;else if(条件表达式)&#123; 语句...... &#125;else 当该语句执行时会从上到下依次对条件表达式进行求值判断，如果值为true则执行当前语句，如果值为false则继续向下，如果条件都不满足则执行最后的else语句 该语句中只会有一个代码块被执行，一但代码块被执行了，则直接结束语句 1234567891011121314var a = 50;if(a &gt; 100)&#123; console.log(\"活着挺没意思\");&#125;else if(a &gt; 80)&#123; console.log(\"你也老大不小了\");&#125;else if(a &gt; 60)&#123; console.log(\"你该退休了\")&#125;else if(a &gt; 40)&#123; console.log(\"你已经中年了\")&#125;else if(a &gt; 18)&#123; console.log(\"你已经成年了\")&#125;else&#123; console.log(\"你还是个小孩\")&#125; 条件分支语句条件分支语句也叫作switch语句 switch语句语法 1234567891011121314switch(条件表达式)&#123; case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; &#125; 执行流程： switch…case…语句在执行时依次将case后的表达式的值和switch后的条件表达式的值进行全等比较 如果比较结果为true，则从当前case处开始执行代码，当前case后的所有代码都会执行，所以语句后面需要break;这样可以确保只执行当前case后的语句，而不会执行其他的case 如果比较结果为false，则继续向下比较。 如果所有的比较结果都为false则执行default后面的语句 12345678910111213141516171819202122232425var a = 1;switch(a)&#123; case 1: console.log(\"壹\") break; case 2: console.log(\"贰\") break; case 3: console.log(\"叁\") break; default: console.log(\"非法数字\") break;&#125;var a = 1;switch(true)&#123; case a &gt;= 60: console.log(\"及格\") break; default: console.log(\"不合格\") break;&#125; 循环语句通过循环语句可以反复执行一段代码多次 while循环 语法： 123while(条件表达式)&#123; 语句...; &#125; while语句在执行时，先对条件表达式进行求值判断，如果值是true，则执行循环体，循环体执行完毕后，继续对表达式进行判断，如果为true则继续执行循环体，循环此操作……..直到条件表达式判断为false则停止循环 1234var n = 1;while(true)&#123; alert(n++);&#125;//不停的弹出自增的数字；这样的叫做死循环，该循环不会停止除非关闭浏览器，开发慎用 可以用break跳出循环 1234567var n = 1;while(true)&#123; alert(n++); if(n&gt;10)&#123; break;//跳出循环 &#125;&#125; 创建一个循环，往往需要三个步骤 1234567891011//1、初始化一个变量var i = 0;//2、在循环中设置一个条件表达式while(i &lt; 10)&#123; alert(1);&#125;//3、定义一个更新表达式，每次更新初始化变量while(i &lt; 10)&#123; alert(i); i++;&#125; do…while循环 语法： 123do&#123; 语句...；&#125;while(条件表达式) 执行流程： do…while语句在执行时，会先执行循环体，循环体执行完以后，在对while后面的条件表达式进行判断，如果结果为true则继续执行循环体，如果结果为false则终止循环 实际上这两个语句相似，不同的是while是先判断再执行，do…while是先执行再判断（do…while可以保证循环体至少执行一次） for循环在for循环中，为我们提供了专门的位置来放三个表达式： 1、初始化表达式 2、条件表达式 3、更新表达式 语法： 1234567for(初始化表达式;条件表达式;更新表达式)&#123; 语句... &#125; for(var i = 0 ; i &lt; 10 ; i++)&#123; alert(i);&#125; 执行流程 1.执行初始化表达式，初始化变量。（初始化表达式只能执行一次） 2.执行条件表达式，判断是否执行循环，如果为true则执行循环，如果为false则终止循环。 3.执行更新表达式，更新表达式执行完毕继续重复第二步 for循环中的三个部分都可以省略，也可以写在外部 123456789var i = 0;for(;i&lt;10;)&#123; alert(i++);&#125;//循环输出10次for(;;)&#123; \"hello\"&#125;//死循环输出hello 终止break break关键字可以用来退出switch或循环语句(不能在裸if语句中使用) break关键字会立即终止离他最近的那个循环语句 123456789101112for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); break;&#125;for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); if(i&gt;5)&#123; break;//此时break作用于外部的for &#125;&#125; 可以为外循环创建一个label，来标识当前的循环 label:循环语句 使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的 12345678outer:for(var i=0 ; i&lt;10 ; i++)&#123; document.write(@i); for(var j=0 ; j&lt;10 ; j++)&#123; document.write(i); break outer;//直接结束外部循环 &#125; &#125; continue continue关键字可以跳过当次循环 continue只能用于循环语句 同样continue也是默认对离他最近的循环起作用 123456for(var i=0 ; i&lt;10 ; i++)&#123; document.write(i); if(i == 5)&#123; continue;//输出了除了5的小于10的正整数（跳过了i=5的本次循环） &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"}]},{"title":"上传博客图片无法显示问题","slug":"上传博客图片无法显示问题","date":"2020-04-23T09:25:29.000Z","updated":"2020-04-23T09:36:00.231Z","comments":true,"path":"2020/04/23/上传博客图片无法显示问题/","link":"","permalink":"https://xingkai520.github.io/2020/04/23/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/","excerpt":"上传博客无法引用本地图片问题","text":"上传博客无法引用本地图片问题 ## 1.下载插件 首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 123npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save或npm install hexo-asset-image --save 2.要将要引入的图片放入与md文件同名的文件夹中在下载插件完成之后再git bush中输入hexo n “text”可生成一个新的md文件和同名文件夹，将你要引入的图片放入这个文件夹内引用 3.在引入图片时不能使用Markdown语法引入不能使用 1![](img&#x2F;img.png) 应使用 1&#123;% asset_img 图片.jpg 图片描述 %&#125; 例如： 使用 1![](img&#x2F;img.png) 可以在本地看到图片但上传至hexo中看不到图片,使用 1&#123;% asset_img 图片.jpg 图片描述 %&#125; 能让你上传至hexo的文章中看到图片但在本地看不到。 我是为了本地观察方便也将写入其中，但不影响上传","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://xingkai520.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"viewport","slug":"viewport","date":"2020-04-23T08:26:09.000Z","updated":"2020-04-23T09:36:39.197Z","comments":true,"path":"2020/04/23/viewport/","link":"","permalink":"https://xingkai520.github.io/2020/04/23/viewport/","excerpt":"viewport的属性","text":"viewport的属性 1width=device-width 视口的宽度 通常设置成device-width(设备自身的宽度) 1initial-scale=1 设置页面的初始缩放值 1maxinum-scale=1.0 允许用户的最大缩放值 是一个数字 可以是小数 1mininum-scale=1.0 允许用户的最小缩放值 是一个数字 可以是小数 1user-scalable=no user-scalable : 用户是否可以手动缩放，值可以是：①yes、 true允许用户缩放；②no、false不允许用户缩放 1viewport-fit: cover; 应对留海屏幕的填充问题 (1) inital-scale也是用来设置视口的，前面说了，width是用来设置视口，其实有这样一个公式，如下： 视口 = 设备独立像素宽度 / inital-scale 可以通过inital-scale间接地设置视口，操作如下： 现在不让inital-scle是1，设置成2，如下： 那假如我把inital-scale=0.5，效果如下： 此时，我们设置视口，就有两种方式，如下： 12width=device-wdithinital-scale = 1 如果有一个人，它设置了width=device-wdith，又设置了inital-scale = 1，以谁为主。如果说你这样设置了，不放大，也不缩小，如下： 如果这样设置，如下： 则以最大的为主：","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Javascript基础","slug":"javascript基础","date":"2020-04-22T12:28:30.000Z","updated":"2020-04-29T10:00:17.054Z","comments":true,"path":"2020/04/22/javascript基础/","link":"","permalink":"https://xingkai520.github.io/2020/04/22/javascript%E5%9F%BA%E7%A1%80/","excerpt":"Javascript基础","text":"Javascript基础 ### **基本知识：** 控制浏览器弹出一个警告框 1alert(\"帅帅帅\") 让浏览器在界面中输出一个内容(向body中输出一个内容) 1document.write(\"你好！！！\") 向控制台输出一个内容 1console.log(\"控制台你好！！！\") 可以将js代码写到标签的onclick属性中。不方便维护，不推荐使用。 1&lt;button onclick=\"alert('点我干嘛--');\"&gt;点我点我&lt;/button&gt; 可以将js代码写在超链接的href属性中，这样当点击超链接时会执行js代码（前面必须加上JavaScript：） 1&lt;a href=\"javascript:alert('让你点你就点-_-!');\"&gt;也点我点我&lt;/a&gt; 一般是写在js文件中用以下代码连接 1&lt;script type=\"text/javascript\" src=\"./js/index.js\"&gt;&lt;/script&gt; 一但这个script标签用于引入外部js文件，那么这个script标签再编写代码将被浏览器忽略 如果需要则需要再写一个script标签 执行顺序从上到下执行 字面量 都是一些不可改变的量 比如：1 2 3 4 5。字面量都是可以直接使用的，如下 1alert(2132146489); 字面量都是可以直接使用，但是我们一般都不会直接使用字面量 变量变量可以用来保存字面量，而且变量的值是可以任意改变的 变量更加方便使用，所以在开发中都是通过变量去保存一个字面量 很少直接使用字面量 声明变量：在js中使用var关键字来声明一个变量 1var a; 需要给变量赋值 1a = 123; 可以声明和赋值同时进行 1var b = 846815; 标识符在js中所有的可以由我们自主命名的都可以称为是标识符 例如：变量名、函数名、属性名都属于标识符 命名一个标识符时需要遵守如下的规则： 1.标识服中可以含有字母、数字、_、$ 2.标识符不能以数字开头 3.标识符不能是ES中的关键字或保留字 4.标识符一般采用驼峰命名法（首字母小写，每个开头字母大写，其余字母小写。不强制要求，但是是个好习惯） 5.JS底层保存标识符时实际上是采用Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符 6.var只在声明变量时使用，在后续需要修改时不需要再重复给一个变量var 12345678var a_1$ = 3;var var = 3；//不能这样helloWorld xxxYyyZzz//驼峰命名法var 我最帅 = 384;//可以用，但是不推荐这样用，不符合行业规范var str1 = 1;str1 = 2;//最后命名的变量值有效 数据类型数据类型指的就是字面量的类型 在JS中一共有六种数据类型： String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中String Number boolean Null Undefined属于基本数据类型，而Object属于引用数据类型 用法 String 字符串 在Js中字符串需要使用引号引起来 单引号和双引号都可以用没区别，但是不要混着用 不要在双引号中放双引号 可以在单引号中用双引号 在字符串中我们可以使用\\作为转义字符，当表示一些特殊符号时可以使用\\转义 1234567891011var str = \"hello\";console.log(str);var str = 'hello\"; //不要混着用var str = \"我说：\"今天天气真不错！\"\";//这样不对，会把”我说：“看做一个变量var str = '我说：\"今天天气真不错！\"';//这样可以var str = \"我说：\\\"今天天气真不错！\\\"\";//这样也可以，让里面的双引号仅仅代表双引号\\' 表示 ’\\\" 表示 \"\\n 表示换行\\t 制表符 \\\\ 表示\\ 我转义我自己 Number 数值 在JS中所有数值都是Number类型，包括整数和浮点数（小数） 数字123和字符123完全不同 可以使用一个typeof来检查一个变量类型 typeof+变量 JS中可以表示数字的最大值：Number.MAX_VALUE 可以用Number.MAX_VALUE*Number.MAX_VALUE，取最大值的平方 如果超过了最大值则会输出Infinity，表示正无穷；-Infinity表示负无穷 用两个字符串相乘：abc*bcd会输出NaN；NaN是一个特殊的数字，表示Not a number（不是数字） 使用typeof检查NaN会返回number Number.MIN_VALUE的值为0以上的最小值0.000000….. 在Js中整数的运算基本可以保证精确 如果使用JS进行浮点元素的计算，可能的到一个不精确的解果；因为二进制无法精确1/10; 可以把后面的数字给省略掉，但前提是不能涉及到钱，所以不要用JS计算精确度要求比较高的运算 1234567891011121314var a = 123;//数字123var b = \"123\";//字符123console.log(typeof a)//检查字符串时，会返回string；检查数值时，会返回numberconsole.log(Number.MAX_VALUE);a = Number.MAX_VALUE*Number.MAX_VALUE;//会输出Infinity，a = \"abc\"*\"bcd\"//输出NaNconsole.log(typeof a)//会输出numbera = Number.MIN_VALUEconsole.log(a)//输出5e-324var c = 1234456 + 4894894;//输出结果正确var c = 0.1 + 0.2;//输出结果为0.30000000000000000004 Boolean 布尔值 布尔值只有两个：true、false；真、假。主要用来做逻辑判断 true：表示真 false：表示假 使用typeof检查会输出boolean 123var bool = ture;console.log(bool);//输出为trueconsole.log(typeof bool)//输出为boolean Null类型的值只有一个，就是Null null（空值）专门用来表示为空的对象 使用typeof检查null会返回Object Undefined（未定义）类型的值只有一个，就是Undefined 当声明一个变量，但是不给变量赋值时，他的值就是Undefined 12345var a = null;console.log(a);//输出就是nullconsole.log(typeof a);//输出是Objectvar b = undefined;console.log(typeof b);//输出是undefined 其他进制数字 在js中如果需要表示16进制的数字，则需要以0x开头 如果要表示8进制的数字，则需要以0开头 如果要表示2进制的数字，则需要以0b开头，但是不是所有的浏览器都支持 输出的时候会转换为10进制输出 1234567//16进制var a = 0x10;console.log(a);//输出为16//8进制var a = 070;console.log(a);//输出为56 强制类型转换 指讲一个数据类型强制转换为其他的数据类型 类型转换主要指，将其他的数据类型，转换为：String、Number、Boolean 将其他的数据类型转换为String 方式一 调用被转换数据类型的toString()方法 该方法不会影响到原变量，会将转换的结果返回 但是要注意Null和Undefined这两个值没有toString方法，如果用这个方法调用会报错 方式二 调用String()函数，并将被转换的数据作为参数传递给函数 String（）函数做强制类型转换时对于Number和Boolean实际上就是调用toString()方法 但对于Null和Undefined，就不会和toString（）一样，他会将Null和Undefined直接转换为字符串“Null”和“Undefined” 将其他数据类型转换为Number 没有toNumber方式 方式一 使用Number()函数 1.如果是纯数字的字符串，则将其转换为数字 2.如果字符串中有非数字的内容，则转换为NaN 3.如果字符串为空串或者是一个全空格的字符串，则转换为数字0 4.true转换成数字1，false转换成数字0，Null转换成数字0，Undefined转换为NaN 方式二 这种方式专门用来对付字符串 parseInt（）把一个字符串转换为一个整数 可以将一个字符串中有效的整数内容取出来然后转换为Number，只读到从左到右第一个不为数字的地方 parseFloat（）把一个字符串转换为一个浮点数（小数） 可以将一个字符串的有效的小数取出，如果有两个小数点，则读到第二个小数点前 如果对String使用parseFloat（）、parseInt（），他会将其先转换为string，然后再操作 将其他数据类型转换为Boolean类型 方式 使用Boolean（）函数 数字转Boolean，除了0和NaN其余的都是true 字符串转Boolean，除了空串其余的都是true Null与Undefined转换为Boolean，都是false 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//将其他的数据类型转换为String//方式一：var a = 123;console.log(typeof a);//输出为Numberconsole.log(a);//输出为123a.toString();//调用a的toString()方法console.log(typeof a);//输出仍为Numbervar b = a.toString();console.log(typeof b);//输出为Stringconsole.log(b);//输出为123a = a.toString();//可以赋值给自己console.log(typeof a);//输出为Stringconsole.log(a);//输出为123a = true;a = toString();console.log(typeof a);//输出为Stringconsole.log(a);//输出为truea = Null;a = toString();//报错a = Undefined;a = toString();//报错//方式二：var a = 123;String(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123a = 123;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为123a = Null;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为Nulla = Undefined;a = String(a);console.log(typeof a);//输出为Stringconsole.log(a);//输出为Undefined//将其他数据类型转换为Number：//方式1：var a = \"123\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"abc\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = true;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为1var a = false;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = Null;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为0var a = Undefined;Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaN//方式二：parseInt();var a = \"123px\";Number(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"123px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"123a564px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = \"a123px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaNvar a = \"123.456px\";parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123var a = 123.456;parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123,可以用来取整//parseFloat();var a = \"123.456px\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123.456var a = \"123.456.789px\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为123.456var a = \"true\";parseFloat(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为NaN//转换其他进制时//转换8进制，这种字符串，有些浏览器（IE）会当成8进制解析，有些浏览器会当成10进制解析var a = 070;a = parseInt(a);console.log(typeof a);//输出为Numberconsole.log(a);//输出为56（或70）//可以在parseInt（）中传递第二个参数，来制定数字的进制var a = 070;a = parseInt(a,10);//把070当做10进制看console.log(typeof a);//输出为Numberconsole.log(a);//输出为70var a = 070;a = parseInt(a,8);//把070当做8进制看console.log(typeof a);//输出为Numberconsole.log(a);//输出为56//将其他数据类型转换为Boolean类型//数字转换为Boolean：var a = 123;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为truevar a = 0;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为falsea = -123;//truea = Infinity;//truea = NaN;//falsea = \"true\"//字符串转换为Boolean：var a = \"\";a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为false//Null与Undefined转换为Boolean：var a = Null;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为falsevar a = Undefined;a = Boolean(a)console.log(typeof a);//输出为Booleanconsole.log(a);//输出为false 运算符 运算符也叫作操作符 通过运算符可以对一个或多个值进行运算 比如：typeof就是运算符，可以用来获得一个值的类型，他会将该值的类型以字符串的形式返回 1234var a = 123;var result = typeof a;console.log(result);//输出numberconsole.log(typeof result);//输出string 算数运算符 +可以对两个值进行加法运算，并将值返回，如果对字符串进行加法操作则会对两个字符串做拼接处理，任何值和字符串做加法运算都是要将其转换成字符串然后再拼串处理；可以利用这一特点可以将任意类型的数据加一空串””就可以将这个数据类型变为字符串类型 -可以对两个值进行减法运算，并将值返回 *可以对两个值进行乘法运算，并将值返回 /可以对两个值进行除法运算，并将值返回 %取模运算（取余数） 对于非Number类型的值进行运算时，会将这些值转换成Number然后运算(除了加法)，可以通过给一个值-0，*1，/1,都可以转换为number类型 任何值和NaN做运算都得NaN 123456789101112131415161718192021222324252627282930313233343536var a = 1;var result;result = a + 1;//输出2result = true + 1;//输出2result = true + false;//输出1result = null + 1;//输出1result = NaN + 1;//输出NaNresult = \"123\" + \"456\";//输出123456；string类型result = \"你好\" + \"帅哥\";//输出你好帅哥；string类型var str = \"锄禾日当午，\" + //双引号必须在一行 \"汗滴禾下土。\" + \"谁知盘中餐，\" + \"粒粒皆辛苦。\";console.log(str);//输出锄禾日当午，汗滴禾下土。谁知盘中餐，粒粒皆辛苦。var c = 123;c = c + \"\";console.log(typeof c);//输出为stringconsole.log(c);//输出为123//减法：var result;result = 100 - \"1\";//输出99result = 2 * \"8\";//输出16var c = 123;c = c - 0;console.log(typeof c);//输出为numberconsole.log(c);//输出为123//取模：var a = 9 % 3;console.log(a);//输出为0var a = 9 % 4;console.log(a);//输出为1 一元运算符 一元运算符只需要一个操作数 +：正号 正号不会对数字产生任何影响，可以将其他类型转换为number类型 -：负号 负号可以对数字进行数字取反,对于非number值，先转换成number再进行取反 123456789101112131415161718192021222324252627var a = 123;a = +a;console.log(a);//输出为123var a = 123;a = -a;console.log(a);//输出为-123var a = true;a = -a;console.log(a);//输出为-1console.log(typeof a);//输出为numbervar a = \"123\";a = +a;console.log(a);//输出为123console.log(typeof a);//输出为numbervar a;a = 1 + \"2\" + 3;console.log(a);//输出为123console.log(typeof a);//输出为stringvar a;a = 1 + +\"2\" + 3;console.log(a);//输出为6console.log(typeof a);//输出为number 自增自减 自增：++ 通过自增可以使变量在自身的基础上增加1 对一个变量自增后，原变量会立即加1 自增分为两种:后++（a++）和前++（++a） 无论是a++还是++a都立即使原变量的值自增1 不同的是a++和++a的值不同 a++的值等于原变量的值（自增前的值） ++a的值等于原变量自增后的值 自减：”–” 通过自减可以使变量在自身的基础上减1 对一个变量自减后，原变量会立即减1 自减分为两种:后”–”（a”–”）和前”–”（”–”a） 无论是a”–”还是”–”a都立即使原变量的值自减1 不同的是a”–”和”–”a的值不同 a”–”的值等于原变量的值（自减前的值） “–”a的值等于原变量自减后的值 1234567891011121314151617181920212223242526272829//自增：var a = 1;a++;console.log(a);//输出为2var a = 1;console.log(a++);//输出为1console.log(a);//输出为2var a = 1;++a;console.log(a);//输出为2var a = 1;console.log(++a);//输出为2console.log(a);//输出为2var a = 20;a = a++ + ++a +a;//20+22+22console.log(a);//输出为2//自减：与自加一样var b = 10;b--;console.log(b);//输出为9var b = 10;--b;console.log(a);//输出为9 逻辑运算符js中为我们提供了3种逻辑运算符 &amp;&amp;与 可以对符号两侧的值进行与运算，并返回结果 两个值中只要有一个值为false就返回false，两个都是true才能返回true JS中的“与“属于短路的与，如果第一个值为false就不再看后面的值 ||或 可以对符号两侧的值进行或运算，并返回结果 只要有一个true就返回true JS中的“或“属于短路的或，如果第一个值为true就不再看后面的值 ！非 可以对一个值进行非运算 就是对一个布尔值进行取反操作 如果对一个非布尔值进行运算，则会将其转换为布尔值然后取反 可以利用这个特点将其他类型转换为布尔值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//&amp;&amp;与var result = true &amp;&amp; true;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = false &amp;&amp; false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; alert(\"你看我出不出来！！\");//运行弹出\"你看我出不出来！！\"var result = false &amp;&amp; alert(\"你看我出不出来！！\");//运行没有弹出\"你看我出不出来！！\"//||或var result = false || false;console.log(result);//输出为falseconsole.log(typeof result);//输出为Booleanvar result = true || false;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true || true;console.log(result);//输出为trueconsole.log(typeof result);//输出为Booleanvar result = true &amp;&amp; alert(\"你看我出不出来！！\");//运行没有弹出\"你看我出不出来！！\"var result = false &amp;&amp; alert(\"你看我出不出来！！\");//运行弹出\"你看我出不出来！！\"//!非var a = true;a = !a;console.log(a);//输出为falsevar a = true;a = !!a;console.log(a);//输出为truevar a = 10;a = !a;console.log(a);//输出为falseconsole.log(typeof a);//输出为Booleanvar a = 10;a = !!a;console.log(a);//输出为trueconsole.log(typeof a);//输出为Boolean 对于非布尔值进行与或运算时，会将其转换为布尔值，然后再运算，并且返回原值 与运算：如果第一个值为true，则直接返回第二个值，如果第一个值为false，则直接返回第一个值（找false） 或运算：如果第一个值为true，则直接返回第一个值，如果第一个值为false，则直接返回第二个值（找true） 12345678910111213141516171819202122232425262728293031323334//与：var a = 1 &amp;&amp; 2;console.log(a);//输出为2var a = 2 &amp;&amp; 1;console.log(a);//输出为1var a = 0 &amp;&amp; 1;console.log(a);//输出为0var a = 1 &amp;&amp; 0;console.log(a);//输出为0var a = NaN &amp;&amp; 0;console.log(a);//输出为NaNvar a = 0 &amp;&amp; NaN;console.log(a);//输出为NaN//或：var a = 2 || 1;console.log(a);//输出为2var a = 1 || 0;console.log(a);//输出为1var a = 1 || NaN;console.log(a);//输出为1var a = NaN || 1;console.log(a);//输出为1var a = NaN || 0;console.log(a);//输出为1 赋值运算符 =：可以将符号右侧的值赋值给符号左侧的变量 +=:a = a + 5等价于a = a + 5（+=不能分开写成+ =） -=:a = a - 5等价于a = a - 5（-=不能分开写成- =） =:a = a * 5等价于a = a * 5（=不能分开写成 * =） /=:a = a / 5等价于a = a / 5（/=不能分开写成/ =） %=:a = a % 5等价于a = a % 5（%=不能分开写成% =） 1234567891011121314151617181920212223242526var a = 123;console.log(a);//输出为123var a = 10;a = a + 5;console.log(a);//输出为15var a = 10;a += 5;console.log(a);//输出为15var a = 10;a -= 5;console.log(a);//输出为5var a = 10;a *= 5;console.log(a);//输出为50var a = 10;a /= 5;console.log(a);//输出为2var a = 10;a %= 5;console.log(a);//输出为0 关系运算符 通过关系运算符可以比较两个值之间的关系，如果关系成立则返回true，不成立则返回false “&gt;”判断左侧关系是否大于右侧，若大于则立即返回true，如果关系不成立则返回false “&gt;=”判断左侧关系是否大于或等于右侧，若大于或等于则立即返回true，如果关系不成立则返回false “==”判断左右是否相等，相等返回true，不相等返回false，NaN不和任何值比较包括他本身，可以用函数isNaN()来判断一个值是否是NaN “===”全等 和相等类似，但是他不会做自动转换，如果两个值类型不同直接返回false “！==”不全等 和不等类似，但是他不会做自动转换，如果两个值类型不同直接返回true “!=”判断左右是否相等，不相等返回true，相等返回false “&lt;=”判断左侧关系是否小于或等于右侧，若小于或等于则立即返回true，如果关系不成立则返回false “&lt;”判断左侧关系是否小于右侧，若小于则立即返回true，如果关系不成立则返回false 对于非数值类型判断，则先将其转化为数值类型再判断 任何数和NaN比都是false 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较，而是比较的Unicode编码，一位一位的对位比较，所以可以借用这个方法对英文进行排序，比较中文没有意义，对于两个字符串的数字比较一定要转型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var a = 5 &gt; 10;console.log(a);//输出为falsevar a = 5 &gt; 4;console.log(a);//输出为truevar a = 5 &gt; 5;console.log(a);//输出为falsevar a = 5 &gt;= 5;console.log(a);//输出为truevar a = 1 &gt; true;console.log(a);//输出为falsevar a = 1 &gt;= true;console.log(a);//输出为falsevar a = 1 &gt; \"0\";console.log(a);//输出为truevar a = 1 &gt; NaN;console.log(a);//输出为false，任何数和NaN比都是falsevar a = true &gt; false;console.log(a);//输出为truevar a = \"5\" &lt; \"11\";console.log(a);//输出为truevar a = \"11\" &lt; \"5\";console.log(a);//输出还是truevar a = \"11\" &lt; +\"5\";console.log(a);//输出还是falsevar a = \"a\" &lt; \"b\";console.log(a);//输出是truevar a = \"b\" &lt; \"a\";console.log(a);//输出是falsevar a = \"abc\" &lt; \"b\";console.log(a);//输出是true，一位一位进行比较var a = \"bbc\" &lt; \"b\";console.log(a);//输出是false，一位一位进行比较var a = \"b\" &lt; \"a\";console.log(a);//输出是falsevar a = NaN == NaN;console.log(a);//输出是falsevar a = NaN;console.log(isNaN(a));//输出是true 条件运算符 条件运算符又叫三元运算符：”条件表达式?语句1:语句2” 条件运算符在执行时，首先对条件表达式进行求值 如果该值为true则执行语句1，并返回执行结果0 如果该值为false则执行语句2，并返回执行结果 如果条件表达式的求值结果是一个非布尔值，会将其转化为布尔值，然后再运算 1234567891011121314151617181920212223242526272829303132true?alert(\"语句1\"):alert(\"语句2\");//执行语句1false?alert(\"语句1\"):alert(\"语句2\");//执行语句2var a = 10;var b = 20;a &gt; b ? alert(\"a大\"):alert(\"b大\");//b大//获取a和b中的最大值var a = 10;var b = 20;var max = a &gt; b ? a : b; console.log(max)//输出b//获取a和b、c中的最大值var a = 10;var b = 20;var c = 50;var max = a &gt; b ? a : b; max = max &gt;c ? max : c;console.log(max)//输出cvar a = 10;var b = 20;var c = 50;var max = a &gt; b ? a &gt; c ? a : c : b &gt; c ? b : c; //a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c); 不推荐使用，不方便阅读console.log(max)//输出50\"hello\"?alert(\"语句1\"):alert(\"语句2\");//执行语句1\"\"?alert(\"语句1\"):alert(\"语句2\");//执行语句2 运算符的优先级 , 运算符：使用，可以分割多个语句，一般可以在声明多个变量时使用（用的最多） 12var a , b , c;var a = 1 , b = 2 , c = 3; 和数学中一样，JS中运算符也有优先级 先乘除后加减 12var result = 1 + 2 * 3;console.log(result)//输出7 &amp;&amp;的优先级比||高 在Js中有一个运算优先级的表，在表中越靠上优先级越高，优先级高的优先计算，如果优先级一样高，则从左到右计算，这个表不需要硬记，如果遇到优先级不清楚的，用（）分开 12var result = 1 || 2 &amp;&amp; 3;console.log(result)//输出1 Unicode编码在字符串中使用转义字符输入unicode编码，\\u+四位编码 12console.log(\"\\u0031\");//输出1console.log(\"\\u2620\");//输出☠（骷髅头） 要在网页中使用Unicode编码 123&lt;h1&gt; &amp;#编码&lt;!--这里的编码需要的是10进制--&gt;&lt;/h1&gt; 代码块（语句） 我们的程序就是由一条条语句构成的 执行的时候从上到下执行 用{}为语句分组 同一个{}我们称为一组语句，要么都执行要么都不执行。也叫作代码块，在}=后不用加； Js中的代码块只有分组的作用没有其他的作用 1elert(\"hello\");//这就是语句 注意 js中严格区分达小写 js中每一条语句以分号结尾（如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，有些时候浏览器会加错分号，所以在开发中必须加分号） js会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 注释多行注释/**/ 单行注释//","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://xingkai520.github.io/tags/Javascript/"}]},{"title":"移动端视口适配","slug":"视口移动端适配","date":"2020-04-16T11:13:58.000Z","updated":"2020-04-23T09:36:28.950Z","comments":true,"path":"2020/04/16/视口移动端适配/","link":"","permalink":"https://xingkai520.github.io/2020/04/16/%E8%A7%86%E5%8F%A3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","excerpt":"移动端视口适配","text":"移动端视口适配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@media screen and (min-width:320px) &#123; html &#123; font-size: 21.33px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:360px) &#123; html &#123; font-size: 24px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:375px) &#123; html &#123; font-size: 25px &#125; body &#123; font-size: 12px &#125;&#125;@media screen and (min-width:384px) &#123; html &#123; font-size: 25.6px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:400px) &#123; html &#123; font-size: 26.67px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:414px) &#123; html &#123; font-size: 27.6px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:424px) &#123; html &#123; font-size: 28.27px &#125; body &#123; font-size: 14px &#125;&#125;@media screen and (min-width:480px) &#123; html &#123; font-size: 32px &#125; body &#123; font-size: 15.36px &#125;&#125;@media screen and (min-width:540px) &#123; html &#123; font-size: 36px &#125; body &#123; font-size: 17.28px &#125;&#125;@media screen and (min-width:720px) &#123; html &#123; font-size: 48px &#125; body &#123; font-size: 23.04px &#125;&#125;@media screen and (min-width:750px) &#123; html &#123; font-size: 50px &#125; body &#123; font-size: 24px &#125;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"标题","slug":"模板","date":"2020-04-05T12:40:00.000Z","updated":"2020-04-23T09:08:25.684Z","comments":true,"path":"2020/04/05/模板/","link":"","permalink":"https://xingkai520.github.io/2020/04/05/%E6%A8%A1%E6%9D%BF/","excerpt":"标题","text":"标题","categories":[],"tags":[{"name":"标签","slug":"标签","permalink":"https://xingkai520.github.io/tags/%E6%A0%87%E7%AD%BE/"}]},{"title":"写博客基础","slug":"我的第一个博客","date":"2020-04-05T12:40:00.000Z","updated":"2020-05-09T01:26:28.964Z","comments":true,"path":"2020/04/05/我的第一个博客/","link":"","permalink":"https://xingkai520.github.io/2020/04/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","excerpt":"Markdown的一些基本语法","text":"Markdown的一些基本语法 **1）标题** 一级标题二级标题三级标题四级标题五级标题六级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 ==2）字体== 加粗 倾斜 ==高亮== 删除线 我是^上标^ 我是下标 1234567891011**加粗***倾斜*&#x3D;&#x3D;高亮&#x3D;&#x3D;~~删除线~~我是^上标^我是~下标~ ==3）列表== 第一级实心圆（按tab换级） 第二级空心圆 第三级实心方框 第四级及之后都是实心方框 按回车取消本级 有序列表 英文状态下的1. 按回车自动添加表头数字 再按回车取消本行 1234567891011+ 第一级实心圆（按tab换级） + 第二级空心圆 + 第三级实心方框 + 第四级及之后都是实心方框按回车取消本级1. 有序列表2. 英文状态下的1.3. 按回车自动添加表头数字4. 再按回车取消本行 ==4）表格== mon tue wed thu 哈哈 哈哈哈 哈哈哈哈 哈哈哈哈哈 啦啦 啦啦啦 啦啦啦啦 啦啦啦啦啦 1234| mon | tue | wed | thu || ---- | ------ | -------- | ---------- || 哈哈 | 哈哈哈 | 哈哈哈哈 | 哈哈哈哈哈 || 啦啦 | 啦啦啦 | 啦啦啦啦 | 啦啦啦啦啦 | ==5）引用== 一级引用 再加&gt;变为二级引用 以此类推 按回车取消一级 1234567&gt; 一级引用&gt;&gt; &gt;再加&gt;变为二级引用&gt; &gt;&gt; &gt;&gt; 以此类推&gt; &gt;&gt;&gt; &gt;&gt; &gt; 按回车取消一级 ==6）分割线== 1-------- ==7）代码== 代码块 12代码块​```+语言 代码 12&#96;代码&#96;","categories":[],"tags":[{"name":"Markdown常用语法","slug":"Markdown常用语法","permalink":"https://xingkai520.github.io/tags/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://xingkai520.github.io/tags/git/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xingkai520.github.io/tags/JavaScript/"},{"name":"博客","slug":"博客","permalink":"https://xingkai520.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://xingkai520.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://xingkai520.github.io/tags/Javascript/"},{"name":"标签","slug":"标签","permalink":"https://xingkai520.github.io/tags/%E6%A0%87%E7%AD%BE/"},{"name":"Markdown常用语法","slug":"Markdown常用语法","permalink":"https://xingkai520.github.io/tags/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}]}